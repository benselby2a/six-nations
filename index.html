<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Six Nations Predictor</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Barlow:wght@400;600;800&family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.4/dist/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* Default Theme (Classic) */
        :root {
            --pitch-green: #1a4d2e;
            --deep-green: #0d2818;
            --gold: #d4af37;
            --bright-gold: #ffd700;
            --white: #fafafa;
            --slate: #2d3436;
            --red: #e74c3c;
            --accent-blue: #3498db;
            --shadow: rgba(0, 0, 0, 0.3);
            --header-font: 'Bebas Neue', cursive;
            --body-font: 'Barlow', sans-serif;
            --bg-gradient: linear-gradient(135deg, var(--deep-green) 0%, var(--pitch-green) 100%);
            --card-bg: rgba(255, 255, 255, 0.05);
            --card-border: var(--gold);
        }

        /* Teletext/Ceefax Theme */
        [data-theme="retro"] {
            --pitch-green: #0a0a12;
            --deep-green: #0a0a12;
            --gold: #cccc00;
            --bright-gold: #e0e0e0;
            --white: #00cccc;
            --slate: #0a0a12;
            --red: #cc3333;
            --accent-blue: #00cccc;
            --shadow: none;
            --header-font: 'VT323', monospace;
            --body-font: 'VT323', monospace;
            --bg-gradient: #0a0a12;
            --card-bg: #0a0a12;
            --card-border: #cccc00;
        }

        [data-theme="retro"] body {
            background: #0a0a12 !important;
            image-rendering: pixelated;
        }

        [data-theme="retro"] body::before {
            display: none;
        }

        [data-theme="retro"] * {
            font-family: 'VT323', monospace !important;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        [data-theme="retro"] h1 {
            font-size: 3rem !important;
            color: #e0e0e0 !important;
            background: #2a2a8a;
            padding: 0.5rem 1rem;
            display: inline-block;
        }

        [data-theme="retro"] h2,
        [data-theme="retro"] h3 {
            color: #33cc33 !important;
            font-size: 1.8rem !important;
        }

        [data-theme="retro"] .subtitle {
            color: #cccc00 !important;
            background: #993333;
            padding: 0.25rem 0.5rem;
            display: inline-block;
        }

        [data-theme="retro"] .match-card,
        [data-theme="retro"] .tries-section,
        [data-theme="retro"] .trevs-tips-box,
        [data-theme="retro"] .tries-stats-box {
            background: #0a0a12 !important;
            border: 2px solid #999933 !important;
            border-radius: 0 !important;
        }

        [data-theme="retro"] .match-card::before {
            display: none;
        }

        [data-theme="retro"] button {
            background: #2a2a8a !important;
            color: #e0e0e0 !important;
            border: 2px solid #9999cc !important;
            border-radius: 0 !important;
            text-transform: uppercase;
        }

        [data-theme="retro"] button:hover {
            background: #993399 !important;
            transform: none;
            box-shadow: none;
        }

        [data-theme="retro"] .tab.active {
            background: #339933 !important;
            color: #0a0a12 !important;
        }

        [data-theme="retro"] .summary-table {
            border-radius: 0 !important;
        }

        [data-theme="retro"] .summary-table thead {
            background: #2a2a8a !important;
            color: #e0e0e0 !important;
        }

        [data-theme="retro"] .summary-table th.competitor-col {
            background: #2a2a8a !important;
        }

        [data-theme="retro"] .summary-table th.rank-col,
        [data-theme="retro"] .summary-table th.pts-col {
            background: #2a2a8a !important;
            color: #e0e0e0 !important;
        }

        [data-theme="retro"] .summary-table td.competitor-name {
            background: #0a0a12 !important;
        }

        [data-theme="retro"] .summary-table td.rank-col,
        [data-theme="retro"] .summary-table td.pts-col {
            background: #0a0a12 !important;
            color: #e0e0e0 !important;
        }

        [data-theme="retro"] .match-header-cell .match-result {
            background: #339933 !important;
            color: #0a0a12 !important;
            border-radius: 0 !important;
        }

        [data-theme="retro"] input,
        [data-theme="retro"] select {
            background: #1a1a4a !important;
            color: #e0e0e0 !important;
            border: 2px solid #999933 !important;
            border-radius: 0 !important;
        }

        [data-theme="retro"] .admin-badge {
            background: #993333 !important;
            border-radius: 0 !important;
        }

        [data-theme="retro"] .trevs-tips-title {
            color: #00cccc !important;
        }

        [data-theme="retro"] .leaderboard-title {
            background: #993333;
            color: #e0e0e0 !important;
            padding: 0.25rem 0.5rem;
            display: inline-block;
        }

        /* Dark Mode Theme */
        [data-theme="dark"] {
            --pitch-green: #1a1a2e;
            --deep-green: #0f0f1a;
            --gold: #6c7a89;
            --bright-gold: #95a5a6;
            --white: #ecf0f1;
            --slate: #2c3e50;
            --red: #c0392b;
            --accent-blue: #2980b9;
            --shadow: rgba(0, 0, 0, 0.5);
            --header-font: 'Bebas Neue', cursive;
            --body-font: 'Barlow', sans-serif;
            --bg-gradient: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%);
            --card-bg: rgba(255, 255, 255, 0.03);
            --card-border: #34495e;
        }

        [data-theme="dark"] body::before {
            opacity: 0.3;
        }

        [data-theme="dark"] h1,
        [data-theme="dark"] h2,
        [data-theme="dark"] h3,
        [data-theme="dark"] .trevs-tips-title {
            color: #bdc3c7 !important;
        }

        [data-theme="dark"] .subtitle {
            color: #7f8c8d !important;
        }

        [data-theme="dark"] .match-card,
        [data-theme="dark"] .tries-section,
        [data-theme="dark"] .trevs-tips-box,
        [data-theme="dark"] .tries-stats-box {
            background: rgba(255, 255, 255, 0.02) !important;
            border-color: #34495e !important;
        }

        [data-theme="dark"] .match-card::before {
            background: linear-gradient(90deg, #34495e, #5d6d7e, #34495e);
        }

        [data-theme="dark"] button {
            background: #34495e !important;
            color: #ecf0f1 !important;
        }

        [data-theme="dark"] button:hover {
            background: #5d6d7e !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        [data-theme="dark"] .tab.active {
            background: #5d6d7e !important;
            color: #ecf0f1 !important;
            border-color: #5d6d7e !important;
        }

        [data-theme="dark"] .summary-table {
            border-color: #34495e !important;
        }

        [data-theme="dark"] .summary-table thead {
            background: #2c3e50 !important;
            color: #ecf0f1 !important;
        }

        [data-theme="dark"] .summary-table th.competitor-col {
            background: #2c3e50 !important;
        }

        [data-theme="dark"] .summary-table th.rank-col,
        [data-theme="dark"] .summary-table th.pts-col {
            background: #2c3e50 !important;
            color: #ecf0f1 !important;
        }

        [data-theme="dark"] .summary-table td.competitor-name {
            background: rgba(15, 15, 26, 0.95) !important;
        }

        [data-theme="dark"] .summary-table td.rank-col,
        [data-theme="dark"] .summary-table td.pts-col {
            background: rgba(15, 15, 26, 0.95) !important;
            color: #f1c40f !important;
        }

        [data-theme="dark"] .match-header-cell .match-result {
            background: rgba(46, 204, 113, 0.2) !important;
            color: #a3e4b7 !important;
        }

        [data-theme="dark"] input,
        [data-theme="dark"] select {
            background: rgba(0, 0, 0, 0.3) !important;
            border-color: #34495e !important;
            color: #ecf0f1 !important;
        }

        [data-theme="dark"] .logout-btn {
            background: rgba(192, 57, 43, 0.6) !important;
        }

        [data-theme="dark"] .admin-tabs-section {
            background: rgba(192, 57, 43, 0.1) !important;
            border-color: #7f3d3d !important;
        }

        /* Theme selector styles */
        .theme-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .theme-selector select {
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--white);
            font-size: 0.85rem;
            font-weight: 700;
            font-family: var(--body-font);
            cursor: pointer;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23d4af37' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            min-width: 130px;
        }

        .theme-selector select:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: var(--gold);
        }

        .theme-selector select:focus {
            border-color: var(--bright-gold);
            background-color: rgba(212, 175, 55, 0.2);
        }

        .theme-selector label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.8;
            margin: 0;
            color: var(--gold);
            font-weight: 700;
        }

        /* App header with theme selector */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--body-font);
            background: var(--bg-gradient);
            color: var(--white);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        /* Animated background pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 50px, rgba(255, 255, 255, 0.02) 50px, rgba(255, 255, 255, 0.02) 100px);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 3rem;
            animation: slideDown 0.8s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-family: 'Bebas Neue', cursive;
            font-size: 5rem;
            letter-spacing: 0.1em;
            color: var(--bright-gold);
            text-shadow: 3px 3px 0 var(--deep-green), 6px 6px 0 rgba(0, 0, 0, 0.3);
            margin-bottom: 0.5rem;
            line-height: 1;
        }

        .subtitle {
            font-size: 1.3rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            color: var(--gold);
            text-transform: uppercase;
        }

        .admin-subtitle {
            font-size: 0.95rem;
            font-weight: 400;
            letter-spacing: 0.03em;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.5rem;
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            justify-content: center;
            animation: fadeIn 1s ease-out 0.3s both;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .tab {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--gold);
            color: var(--white);
            padding: 1rem 1.5rem;
            font-size: 1rem;
            font-weight: 800;
            letter-spacing: 0.03em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            text-align: center;
        }

        .tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .tab:hover::before {
            left: 100%;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--bright-gold);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow);
        }

        .tab.active {
            background: var(--gold);
            color: var(--deep-green);
            border-color: var(--bright-gold);
            box-shadow: 0 5px 20px rgba(212, 175, 55, 0.4);
        }

        /* Login Section */
        .login-section {
            max-width: 500px;
            margin: 4rem auto;
            background: rgba(255, 255, 255, 0.05);
            padding: 3rem;
            border-radius: 10px;
            border: 2px solid var(--gold);
            box-shadow: 0 10px 40px var(--shadow);
            backdrop-filter: blur(10px);
            animation: scaleIn 0.6s ease-out 0.4s both;
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .login-section h2 {
            font-family: 'Bebas Neue', cursive;
            font-size: 2.5rem;
            color: var(--bright-gold);
            margin-bottom: 2rem;
            text-align: center;
            letter-spacing: 0.1em;
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--gold);
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 0.05em;
        }

        input[type="text"],
        input[type="password"],
        input[type="email"],
        input[type="number"] {
            width: 100%;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(212, 175, 55, 0.3);
            color: var(--white);
            font-size: 1rem;
            border-radius: 5px;
            transition: all 0.3s ease;
            font-family: 'Barlow', sans-serif;
        }

        input:focus {
            outline: none;
            border-color: var(--gold);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
        }

        button {
            width: 100%;
            padding: 1.2rem;
            background: var(--gold);
            color: var(--deep-green);
            border: none;
            font-size: 1.1rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::after {
            width: 300px;
            height: 300px;
        }

        button:hover {
            background: var(--bright-gold);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        /* Prediction Section */
        .prediction-section {
            animation: fadeIn 0.8s ease-out;
        }

        .outstanding-banner {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2) 0%, rgba(231, 76, 60, 0.1) 100%);
            border: 2px solid var(--red);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .outstanding-banner-icon {
            font-size: 1.5rem;
        }

        .outstanding-banner-text {
            font-weight: 600;
            color: var(--white);
        }

        .outstanding-banner-count {
            color: var(--red);
            font-weight: 800;
        }

        .match-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            margin-bottom: 0.75rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .match-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--gold), var(--bright-gold), var(--gold));
            transform: translateX(-100%);
            transition: transform 0.5s ease;
        }

        .match-card:hover::before {
            transform: translateX(0);
        }

        .match-card:hover {
            border-color: var(--gold);
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--shadow);
        }

        .match-header {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: var(--bright-gold);
            margin-bottom: 0.75rem;
            letter-spacing: 0.05em;
        }

        .match-teams {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0;
        }

        .team {
            text-align: center;
        }

        .team-name {
            font-size: 1rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .team-flag {
            font-size: 2rem;
            margin-bottom: 0.25rem;
            line-height: 1;
        }

        .match-saved-indicator {
            color: #2ecc71;
            font-weight: bold;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .match-saved-indicator.visible {
            opacity: 1;
        }

        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            cursor: help;
        }

        .tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--deep-green);
            border: 2px solid var(--gold);
            color: var(--white);
            padding: 0.75rem 1rem;
            border-radius: 5px;
            font-size: 0.85rem;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: opacity 0.2s ease, visibility 0.2s ease;
            margin-bottom: 8px;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: var(--gold);
        }

        .tooltip-container:hover .tooltip,
        .tooltip-container.tooltip-active .tooltip {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-line {
            display: block;
            margin: 0.25rem 0;
        }

        .tooltip-line.correct {
            color: #2ecc71;
        }

        .tooltip-line.incorrect {
            color: #e74c3c;
        }

        .tooltip-line.bonus {
            color: var(--bright-gold);
        }

        .score-input {
            width: 70px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 800;
            padding: 0.5rem;
        }

        .vs {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: var(--gold);
            font-weight: 800;
        }

        /* Tries Prediction */
        .tries-section {
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            text-align: center;
        }

        .tries-section h3 {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.8rem;
            color: var(--bright-gold);
            margin-bottom: 0.75rem;
            letter-spacing: 0.1em;
        }

        .tries-input {
            width: 150px;
            font-size: 2rem;
            text-align: center;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        /* Leaderboard */
        .leaderboard {
            animation: fadeIn 0.8s ease-out;
        }


        .points {
            font-weight: 800;
            font-size: 1.3rem;
            color: var(--bright-gold);
        }

        /* Summary Table */
        .summary-match {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            backdrop-filter: blur(10px);
        }

        .summary-match-header {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--gold);
        }

        .summary-match-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .summary-round {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: var(--gold);
            background: rgba(212, 175, 55, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 5px;
        }

        .summary-teams {
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--white);
        }

        .summary-date {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .summary-score {
            text-align: center;
        }

        .actual-score {
            font-family: 'Bebas Neue', cursive;
            font-size: 2.5rem;
            color: var(--bright-gold);
            letter-spacing: 0.05em;
        }

        .score-status {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .summary-predictions-table {
            width: 100%;
            border-collapse: collapse;
        }

        .summary-predictions-table th {
            background: rgba(212, 175, 55, 0.2);
            padding: 0.8rem;
            text-align: left;
            font-weight: 800;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        }

        .summary-predictions-table td {
            padding: 1rem 0.8rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.1);
        }

        .summary-predictions-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .prediction-score {
            font-weight: 800;
            font-size: 1.1rem;
        }

        .points-earned {
            font-weight: 800;
            font-size: 1.2rem;
        }

        .points-4 {
            color: #2ecc71;
        }

        .points-3 {
            color: #3498db;
        }

        .points-0 {
            color: #e74c3c;
        }

        .no-predictions {
            text-align: center;
            padding: 2rem;
            font-style: italic;
            opacity: 0.6;
        }

        .no-result {
            color: var(--gold);
            font-style: italic;
        }

        /* Predictions View */
        .predictions-grid {
            display: grid;
            gap: 2rem;
            animation: fadeIn 0.8s ease-out;
        }

        .user-predictions {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 10px;
            padding: 2rem;
            backdrop-filter: blur(10px);
        }

        .user-predictions h3 {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            color: var(--bright-gold);
            margin-bottom: 1.5rem;
            letter-spacing: 0.05em;
        }

        .prediction-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 1rem;
            padding: 1rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            align-items: center;
        }

        .prediction-row:last-child {
            border-bottom: none;
        }

        .predicted-score {
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--gold);
        }

        .hidden {
            display: none;
        }

        /* Summary table styles */
        .summary-container {
            animation: fadeIn 0.8s ease-out;
            overflow-x: auto;
            position: relative;
        }

        .scroll-hint {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            margin-top: 0.5rem;
            background: rgba(212, 175, 55, 0.15);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 5px;
            color: var(--gold);
            font-size: 0.85rem;
            font-weight: 500;
        }

        .scroll-hint.hidden {
            display: none;
        }

        .scroll-hint-arrow {
            animation: bounceRight 1s ease-in-out infinite;
        }

        @keyframes bounceRight {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(5px); }
        }

        .summary-filters {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .export-btn {
            padding: 0.8rem 1.5rem;
            background: rgba(46, 204, 113, 0.15);
            border: 2px solid rgba(46, 204, 113, 0.4);
            color: #2ecc71;
            font-size: 0.95rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .export-btn:hover {
            background: rgba(46, 204, 113, 0.25);
            border-color: #2ecc71;
            color: #fff;
        }

        .export-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .filter-btn {
            padding: 0.8rem 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(212, 175, 55, 0.3);
            color: var(--white);
            font-size: 0.95rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .filter-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--gold);
        }

        .filter-btn.active {
            background: var(--gold);
            color: var(--deep-green);
            border-color: var(--bright-gold);
        }

        .round-filter-group {
            display: flex;
            align-items: stretch;
            gap: 0;
            flex: 1 1 100%;
        }

        .round-filter-group .filter-btn {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: none;
            flex: 1;
        }

        .round-divider {
            width: 2px;
            background: rgba(212, 175, 55, 0.5);
            align-self: stretch;
        }

        .round-filter-group .filter-btn.active + .round-divider {
            background: var(--bright-gold);
        }

        .round-select {
            padding: 0.8rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-left: none;
            color: var(--white);
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
            flex: 1;
            min-width: 180px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23d4af37' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            padding-right: 2.5rem;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        .round-select:focus {
            outline: none;
            border-color: var(--gold);
        }

        .round-select:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: var(--gold);
        }

        .round-filter-group .filter-btn.active + .round-divider + .round-select {
            background-color: rgba(212, 175, 55, 0.3);
            border-color: var(--bright-gold);
        }

        .summary-table {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid var(--gold);
            backdrop-filter: blur(10px);
            border-collapse: separate;
            border-spacing: 0;
            table-layout: auto;
        }

        .summary-table thead {
            background: var(--gold);
            color: var(--deep-green);
        }

        .summary-table th {
            padding: 1rem 0.8rem;
            font-family: 'Bebas Neue', cursive;
            font-size: 1.1rem;
            letter-spacing: 0.05em;
            text-align: center;
            vertical-align: bottom;
        }

        /* Sticky rank column */
        .summary-table th.rank-col,
        .summary-table td.rank-col {
            position: sticky;
            left: 0;
            z-index: 12;
            min-width: 40px;
            width: 40px;
            text-align: center;
        }

        .summary-table th.rank-col {
            background: var(--gold);
        }

        .summary-table td.rank-col {
            background: rgba(26, 77, 46, 0.98);
            font-weight: 700;
            color: var(--gold);
        }

        /* Sticky competitor name column */
        .summary-table th.competitor-col {
            text-align: left;
            width: 140px;
            min-width: 140px;
            max-width: 180px;
            position: sticky;
            left: 40px;
            background: var(--gold);
            z-index: 20;
        }

        .summary-table td.competitor-name {
            text-align: left;
            font-weight: 700;
            font-size: 0.8rem;
            position: sticky;
            left: 40px;
            background: rgba(26, 77, 46, 0.98);
            z-index: 19;
            border-right: none;
            width: 140px;
            min-width: 140px;
            max-width: 180px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.3;
        }

        /* Sticky points column (3rd from left, after rank + competitor) */
        .summary-table th.pts-col,
        .summary-table td.pts-col {
            position: sticky;
            left: 180px;
            z-index: 12;
            min-width: 50px;
            text-align: center;
            box-shadow: 2px 0 6px rgba(0, 0, 0, 0.25);
        }

        .summary-table th.pts-col {
            background: var(--gold);
        }

        .summary-table td.pts-col {
            background: rgba(26, 77, 46, 0.98);
            font-weight: 800;
            font-size: 1.1rem;
            color: var(--bright-gold);
        }

        .summary-table td {
            padding: 0.8rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            text-align: center;
            font-size: 0.95rem;
            white-space: nowrap;
        }

        .summary-table tr:hover td {
            background: rgba(255, 255, 255, 0.1);
        }

        .summary-table tr:hover td.rank-col,
        .summary-table tr:hover td.competitor-name,
        .summary-table tr:hover td.pts-col {
            background: rgba(26, 77, 46, 1);
        }

        /* Highlight current logged in user */
        .summary-table tr.current-user-row td {
            background: rgba(212, 175, 55, 0.15);
        }

        .summary-table tr.current-user-row td.rank-col,
        .summary-table tr.current-user-row td.competitor-name,
        .summary-table tr.current-user-row td.pts-col {
            background: rgba(212, 175, 55, 0.25);
        }

        .summary-table tr.current-user-row td.competitor-name {
            border-left: 3px solid var(--bright-gold);
        }

        .summary-table tr.current-user-row:hover td {
            background: rgba(212, 175, 55, 0.25);
        }

        .summary-table tr.current-user-row:hover td.competitor-name {
            background: rgba(212, 175, 55, 0.35);
        }

        .match-header-cell {
            font-size: 0.9rem;
            line-height: 1.3;
            padding: 0.6rem 0.6rem !important;
            text-align: center !important;
            min-width: 100px;
            vertical-align: top !important;
            height: 100%;
        }

        .match-header-cell-inner {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
            min-height: 140px;
        }

        .match-header-top {
            text-align: center;
        }

        .match-header-bottom {
            text-align: center;
            margin-top: auto;
            padding-top: 0.5rem;
        }

        .match-header-cell .match-teams {
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
            text-align: center !important;
            display: block;
        }

        .match-header-cell .match-date {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-bottom: 0.3rem;
            text-align: center !important;
            display: block;
        }

        .match-header-cell .match-result {
            font-size: 1.1rem;
            font-weight: 800;
            color: #ffffff;
            background: rgba(46, 204, 113, 0.4);
            padding: 0.25rem 0.6rem;
            border-radius: 3px;
            display: inline-block;
        }

        .match-header-cell .match-tries {
            font-size: 0.7rem;
            opacity: 0.8;
            margin-top: 0.15rem;
            text-align: center !important;
            display: block;
        }

        .match-header-cell .no-result {
            opacity: 0.5;
        }

        .match-teams {
            font-weight: 800;
            margin-bottom: 0.3rem;
        }

        .match-date {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-bottom: 0.3rem;
        }

        .match-result {
            font-size: 1.1rem;
            font-weight: 800;
            color: var(--bright-gold);
        }

        .prediction-cell {
            font-size: 0.9rem;
        }

        .pred-score {
            font-weight: 700;
        }

        .pred-score-win {
            color: #2ecc71;
        }

        .pred-score-lose {
            color: #f2a3a3;
        }

        .pred-score-tie {
            color: var(--bright-gold);
        }

        .points-earned {
            display: inline-block;
            font-weight: 700;
            margin-top: 0.35rem;
            font-size: 0.72rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            border: 1px solid #3a4a64;
            background: #1a2434;
            color: #f4f7fb;
            letter-spacing: 0.02em;
        }

        .points-0 {
            background: #4a2f35;
            border-color: #6a3b44;
            color: #f6d7db;
        }

        .points-3 {
            background: #1f5a4f;
            border-color: #2d7a6a;
            color: #d7f3ee;
        }

        .points-4 {
            background: #2a4f74;
            border-color: #3a6b9b;
            color: #deecff;
        }

        .points-perfect {
            background: #3b5f8d;
            border-color: #4f79b0;
            color: #ecf5ff;
        }

        .points-placeholder {
            visibility: hidden;
        }

        .points-perfect {
            color: #9b59b6;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }

        /* Tries stats box */
        .tries-stats-box {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--gold);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .tries-stats-title {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: var(--bright-gold);
            margin-bottom: 1rem;
            letter-spacing: 0.1em;
        }

        .tries-stats-grid {
            display: flex;
            justify-content: center;
            gap: 3rem;
            flex-wrap: wrap;
        }

        .tries-stat {
            text-align: center;
        }

        .tries-stat-value {
            font-family: 'Bebas Neue', cursive;
            font-size: 2.5rem;
            color: var(--bright-gold);
            line-height: 1;
        }

        .tries-stat-label {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.3rem;
        }

        /* Trev's Tips box */
        .trevs-tips-box {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--gold);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .trevs-tips-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .trevs-tips-title {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: var(--bright-gold);
            letter-spacing: 0.1em;
        }

        .trevs-tips-emoji {
            font-size: 1.5rem;
        }

        .trevs-tips-content {
            font-size: 1rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
            font-style: italic;
        }

        /* Joker styles - My Predictions page */
        .joker-selection {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(212, 175, 55, 0.2);
            text-align: center;
        }

        .joker-label {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            border: 2px solid rgba(212, 175, 55, 0.3);
            background: rgba(212, 175, 55, 0.1);
            transition: all 0.3s ease;
        }

        .joker-label:hover {
            border-color: var(--gold);
            background: rgba(212, 175, 55, 0.2);
        }

        .joker-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .joker-icon {
            font-size: 1.2rem;
        }

        .joker-text {
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--bright-gold);
        }

        .match-card.joker-selected {
            border-color: var(--bright-gold);
            background: rgba(212, 175, 55, 0.15);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .match-card.joker-selected .joker-label {
            background: rgba(212, 175, 55, 0.3);
            border-color: var(--bright-gold);
        }

        /* Joker styles - Match Summary table */
        .joker-indicator {
            font-size: 0.8rem;
            margin-left: 0.25rem;
        }

        .joker-score {
            font-weight: 700;
        }

        .joker-eligible-header {
            background: rgba(212, 175, 55, 0.15) !important;
        }

        .joker-eligible-badge {
            font-size: 0.65rem;
            color: var(--bright-gold);
            background: rgba(212, 175, 55, 0.3);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            margin-bottom: 0.3rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .tooltip-line.joker-bonus {
            color: var(--bright-gold);
            font-weight: 700;
        }

        /* Supported teams picker */
        .team-flags-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .team-flag-option {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.4rem 0.7rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }

        .team-flag-option:hover {
            border-color: rgba(212, 175, 55, 0.5);
            background: rgba(212, 175, 55, 0.1);
        }

        .team-flag-option.selected {
            border-color: var(--bright-gold);
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
        }

        .team-flag-option .flag-emoji {
            font-size: 1.2rem;
        }

        .supported-team-flags {
            margin-right: 0.3rem;
            font-size: 0.9rem;
        }

        /* User info */
        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .user-info .username {
            font-family: var(--body-font);
            font-size: 0.9rem;
            color: var(--white);
            letter-spacing: 0.02em;
            font-weight: 600;
        }

        .logout-btn {
            width: auto;
            padding: 0.4rem 1rem;
            margin: 0;
            background: rgba(231, 76, 60, 0.8);
            font-size: 0.75rem;
            border-radius: 15px;
        }

        .logout-btn:hover {
            background: var(--red);
            transform: none;
            box-shadow: none;
        }

        /* Admin badge adjustment for smaller user info */
        .user-info .admin-badge {
            font-size: 0.65rem;
            padding: 0.15rem 0.4rem;
            margin-left: 0.25rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .subtitle {
                font-size: 1rem;
            }

            .container {
                padding: 1rem;
            }

            .match-teams {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }

            .vs {
                display: none;
            }

            .score-input {
                width: 60px;
                font-size: 1.2rem;
            }

            .tabs {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .tab {
                padding: 0.6rem 0.8rem;
                font-size: 0.75rem;
                flex: 1 1 auto;
                min-width: fit-content;
                letter-spacing: 0.02em;
            }
            
            .app-header {
                flex-direction: column;
                gap: 0.75rem;
                align-items: stretch;
            }
            
            .theme-selector {
                justify-content: center;
            }
            
            .user-info {
                justify-content: center;
            }
            
            .filter-btn {
                padding: 0.6rem 1rem;
                font-size: 0.8rem;
                flex: 1 1 auto;
            }
            
            .summary-filters {
                gap: 0.5rem;
            }

            .export-btn {
                padding: 0.6rem 1rem;
                font-size: 0.8rem;
                margin-left: 0;
                flex: 1 1 100%;
                justify-content: center;
            }

            .round-filter-group {
                flex: 1 1 100%;
            }
            
            .round-filter-group .filter-btn {
                flex: 1;
            }
            
            .round-select {
                padding: 0.6rem 0.5rem;
                font-size: 0.8rem;
                min-width: 60px;
            }
            
            /* Summary table mobile adjustments */
            .summary-table th.rank-col,
            .summary-table td.rank-col {
                min-width: 30px;
                width: 30px;
                padding: 0.5rem 0.3rem;
                font-size: 0.85rem;
            }
            
            .summary-table th.competitor-col,
            .summary-table td.competitor-name {
                min-width: 110px;
                max-width: 140px;
                padding: 0.5rem;
                font-size: 0.8rem;
                left: 30px;
            }
            
            .summary-table th.pts-col,
            .summary-table td.pts-col {
                min-width: 40px;
                padding: 0.5rem 0.3rem;
                font-size: 0.9rem;
                left: 140px;
            }

            .summary-table td {
                padding: 0.5rem;
                font-size: 0.8rem;
            }
            
            .match-header-cell {
                min-width: 80px !important;
                padding: 0.4rem !important;
                font-size: 0.75rem;
            }
            
            .match-header-cell-inner {
                min-height: 100px;
            }
            
            .match-header-cell .match-teams {
                font-size: 0.7rem;
            }
            
            .match-header-cell .match-date {
                font-size: 0.6rem;
            }
            
            .outstanding-banner {
                flex-direction: column;
                text-align: center;
                gap: 0.5rem;
                padding: 0.75rem 1rem;
            }
            
            .match-card {
                padding: 0.75rem 1rem;
            }
            
            .match-header {
                font-size: 1rem;
            }
            
            .team-name {
                font-size: 0.9rem;
            }
            
            .team-flag {
                font-size: 1.75rem;
            }
            
            .tries-section {
                padding: 1rem;
            }
            
            .tries-section h3 {
                font-size: 1.5rem;
            }
            
            .tries-input {
                width: 100px;
                font-size: 1.5rem;
            }
            
            .admin-tabs-section {
                padding: 0.75rem;
            }
            
            .admin-tabs-label {
                font-size: 0.75rem;
            }
            
            .lock-banner, .unlock-banner {
                font-size: 0.85rem;
                padding: 0.75rem;
            }
            
            .btn-small {
                padding: 0.5rem 1rem !important;
                font-size: 0.7rem !important;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 0.9rem;
            }
            
            .tab {
                font-size: 0.65rem;
                padding: 0.5rem 0.6rem;
                letter-spacing: 0.01em;
            }
            
            .filter-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.7rem;
            }

            .summary-table th.rank-col,
            .summary-table td.rank-col {
                min-width: 24px;
                width: 24px;
                padding: 0.35rem 0.25rem;
                font-size: 0.75rem;
            }

            .summary-table th.competitor-col,
            .summary-table td.competitor-name {
                min-width: 90px;
                max-width: 110px;
                padding: 0.4rem;
                font-size: 0.72rem;
                left: 24px;
            }

            .summary-table th.pts-col,
            .summary-table td.pts-col {
                min-width: 36px;
                padding: 0.35rem 0.25rem;
                font-size: 0.8rem;
                left: 114px;
            }

            .summary-table td {
                padding: 0.4rem;
                font-size: 0.72rem;
            }

            .match-header-cell {
                min-width: 70px !important;
                padding: 0.3rem !important;
                font-size: 0.68rem;
            }

            .match-header-cell-inner {
                min-height: 90px;
            }
            
            .match-header {
                font-size: 0.9rem;
            }
            
            .team-name {
                font-size: 0.8rem;
            }
            
            .team-flag {
                font-size: 1.5rem;
            }
            
            .score-input {
                width: 55px;
                font-size: 1rem;
                padding: 0.4rem;
            }
            
            .theme-selector select {
                font-size: 0.75rem;
                padding: 0.4rem 2rem 0.4rem 0.75rem;
                min-width: 110px;
            }
            
            .theme-selector label {
                font-size: 0.65rem;
            }
            
            .logout-btn {
                font-size: 0.65rem;
                padding: 0.3rem 0.75rem;
            }
            
            .user-info .username {
                font-size: 0.8rem;
            }
            
            .outstanding-banner {
                font-size: 0.85rem;
            }
            
            .outstanding-banner-icon {
                font-size: 1.2rem;
            }
            
            .login-section {
                padding: 1.5rem;
            }
            
            .login-toggle {
                flex-direction: column;
            }
            
            .toggle-btn {
                width: 100%;
            }
            
            button {
                padding: 1rem;
                font-size: 0.95rem;
            }
            
            input[type="text"],
            input[type="password"],
            input[type="email"],
            input[type="number"] {
                padding: 0.8rem;
                font-size: 0.95rem;
            }
            
            .btn-small {
                padding: 0.4rem 0.8rem !important;
                font-size: 0.65rem !important;
            }
            
            .results-table th,
            .results-table td {
                padding: 0.4rem;
                font-size: 0.7rem;
            }
            
            .results-table input,
            .results-table select {
                font-size: 0.7rem;
                padding: 0.3rem;
            }
        }
        
        @media (max-width: 380px) {
            h1 {
                font-size: 1.75rem;
            }
            
            .tab {
                font-size: 0.6rem;
                padding: 0.45rem 0.5rem;
            }
            
            .filter-btn {
                font-size: 0.65rem;
                padding: 0.4rem 0.6rem;
            }
        }

        /* Login feedback */
        .login-feedback {
            padding: 1rem;
            border-radius: 5px;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
            animation: slideDown 0.3s ease-out;
        }

        .login-feedback.success {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid #2ecc71;
            color: #2ecc71;
        }

        .login-feedback.error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            color: #e74c3c;
        }

        .login-feedback.info {
            background: rgba(52, 152, 219, 0.2);
            border: 2px solid #3498db;
            color: #3498db;
        }

        /* Admin badge */
        .admin-badge {
            display: inline-block;
            background: var(--red);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        /* Admin tabs section */
        .admin-tabs-section {
            margin-top: 3rem;
            padding: 1rem;
            background: rgba(231, 76, 60, 0.1);
            border: 2px solid var(--red);
            border-radius: 10px;
        }

        .admin-tabs-label {
            color: var(--red);
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            text-align: center;
        }

        .admin-tabs {
            margin-bottom: 0;
            justify-content: space-evenly;
        }

        .admin-tabs .tab {
            border-color: var(--red);
            background: rgba(231, 76, 60, 0.1);
            flex: 1;
        }

        .admin-tabs .tab:hover {
            background: rgba(231, 76, 60, 0.2);
            border-color: var(--red);
        }

        .admin-tabs .tab.active {
            background: var(--red);
            color: white;
            border-color: var(--red);
        }

        /* Lock status banner */
        .lock-banner {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid var(--red);
            color: var(--red);
            padding: 1rem;
            border-radius: 5px;
            margin-bottom: 1.5rem;
            text-align: center;
            font-weight: 600;
            animation: pulse 2s infinite;
        }

        .unlock-banner {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid #2ecc71;
            color: #2ecc71;
            padding: 1rem;
            border-radius: 5px;
            margin-bottom: 1.5rem;
            text-align: center;
            font-weight: 600;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Admin tables */
        .admin-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .admin-table th,
        .admin-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        }

        .admin-table th {
            background: rgba(212, 175, 55, 0.1);
            color: var(--gold);
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 0.05em;
        }

        .admin-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .admin-table input {
            width: 100%;
            max-width: 200px;
        }

        /* Admin action buttons */
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            width: auto;
            display: inline-block;
            margin: 0.2rem;
        }

        .btn-danger {
            background: var(--red);
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #2ecc71;
        }

        .btn-success:hover {
            background: #27ae60;
        }

        .btn-warning {
            background: #f39c12;
            color: var(--deep-green);
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        /* Database Recovery styles */
        .recovery-section {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .recovery-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 10px;
            padding: 1.5rem;
        }

        .recovery-card h3 {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: var(--bright-gold);
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }

        .recovery-card p {
            margin-bottom: 0.75rem;
            line-height: 1.5;
        }

        .recovery-card ul {
            margin: 0.75rem 0 0.75rem 1.5rem;
            line-height: 1.8;
        }

        .recovery-card ul li {
            color: rgba(255, 255, 255, 0.8);
        }

        .recovery-danger {
            border-color: rgba(231, 76, 60, 0.5);
            background: rgba(231, 76, 60, 0.1);
        }

        .sql-preview {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 5px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
            overflow-x: auto;
            white-space: pre;
            max-height: 400px;
            overflow-y: auto;
            color: #a0d0a0;
        }

        /* Lock toggle */
        .lock-toggle {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--gold);
            border-radius: 10px;
            margin-bottom: 2rem;
        }

        .lock-toggle label {
            margin: 0;
            flex: 1;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--red);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(30px);
        }

        /* Tries input in admin */
        .tries-input-small {
            width: 70px;
            text-align: center;
            padding: 0.5rem;
            font-size: 1rem;
        }

        /* Login toggle buttons */
        .login-toggle {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .toggle-btn {
            flex: 1;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(212, 175, 55, 0.3);
            color: var(--white);
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--gold);
        }

        .toggle-btn.active {
            background: var(--gold);
            color: var(--deep-green);
            border-color: var(--bright-gold);
        }

        .login-form {
            animation: fadeIn 0.3s ease-out;
        }

        /* Guest login styles */
        .guest-login-divider {
            display: flex;
            align-items: center;
            margin: 0 0 1.5rem;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
        }

        .guest-login-divider::before,
        .guest-login-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(212, 175, 55, 0.3);
        }

        .guest-login-divider span {
            padding: 0 1rem;
        }

        .guest-login-btn {
            width: 100%;
            padding: 1rem;
            margin-bottom: 1.5rem;
            background: var(--gold);
            border: 2px solid var(--bright-gold);
            color: var(--deep-green);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .guest-login-btn:hover {
            background: var(--bright-gold);
            border-color: var(--bright-gold);
        }

        .guest-badge {
            background: rgba(255, 255, 255, 0.2);
            color: var(--white);
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            margin-left: 0.5rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--deep-green) 0%, var(--pitch-green) 100%);
            border: 2px solid var(--gold);
            border-radius: 10px;
            padding: 2rem;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .btn-cancel {
            background: transparent;
            border: 2px solid var(--gold);
            color: var(--gold);
            margin-top: 0.5rem;
        }

        .btn-cancel:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        /* Results table styles */
        .results-table-container {
            overflow-x: auto;
            margin-top: 1.5rem;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .results-table th,
        .results-table td {
            padding: 0.75rem 0.5rem;
            text-align: center;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        }

        .results-table th {
            background: rgba(212, 175, 55, 0.1);
            color: var(--gold);
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
        }

        .results-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .results-table input[type="text"],
        .results-table input[type="number"] {
            width: 100%;
            padding: 0.4rem;
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
            color: var(--white);
            text-align: center;
            font-size: 0.85rem;
        }

        .results-table input[type="number"] {
            width: 60px;
        }

        .results-table input[type="text"]:focus,
        .results-table input[type="number"]:focus {
            outline: none;
            border-color: var(--gold);
        }

        .results-table select {
            padding: 0.4rem;
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
            color: var(--white);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .results-table select:focus {
            outline: none;
            border-color: var(--gold);
        }

        .results-table .vs-cell {
            font-weight: 700;
            color: var(--gold);
            font-size: 0.8rem;
        }

        .results-table .round-cell {
            font-weight: 700;
            color: var(--bright-gold);
        }

        .results-table .saved-cell {
            color: #2ecc71;
            font-weight: bold;
            font-size: 1.1rem;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-gradient);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-screen.hidden {
            display: none;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(212, 175, 55, 0.3);
            border-top: 4px solid var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            color: var(--gold);
            letter-spacing: 0.1em;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading...</div>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>Six Nations</h1>
            <div class="subtitle">Prediction Challenge 2026</div>
        </header>

        <!-- Login View -->
        <div id="loginView">
            <div class="login-section">
                <h2>Join The Game</h2>
                <div id="loginFeedback" class="login-feedback hidden"></div>

                <!-- Guest Login -->
                <button class="guest-login-btn" onclick="loginAsGuest()">View Scores as Guest</button>
                <div class="guest-login-divider">
                    <span>or</span>
                </div>
                
                <!-- Toggle buttons -->
                <div class="login-toggle">
                    <button class="toggle-btn active" onclick="showLoginForm('existing')">Existing Competitor</button>
                    <!--<button class="toggle-btn" onclick="showLoginForm('new')">New Competitor</button> -->
                </div>

                <!-- Existing User Form -->
                <div id="existingUserForm" class="login-form">
                    <div class="input-group">
                        <label for="existingUsername">Username</label>
                        <input type="text" id="existingUsername" placeholder="Enter your username" onkeypress="handleLoginKeyPress(event, 'existing')">
                    </div>
                    <div class="input-group">
                        <label for="existingPassword">Password</label>
                        <input type="password" id="existingPassword" placeholder="Enter password" onkeypress="handleLoginKeyPress(event, 'existing')">
                    </div>
                    <button onclick="loginExisting()">Login</button>
                </div>

                <!-- New User Form
                <div id="newUserForm" class="login-form hidden">
                    <div class="input-group">
                        <label for="newUsername">Username</label>
                        <input type="text" id="newUsername" placeholder="Choose a username" onkeypress="handleLoginKeyPress(event, 'new')">
                    </div>
                    <div class="input-group">
                        <label for="nickname">Display Name</label>
                        <input type="text" id="nickname" placeholder="How you'll appear on the leaderboard" onkeypress="handleLoginKeyPress(event, 'new')">
                    </div>
                    <div class="input-group">
                        <label for="newPassword">Password</label>
                        <input type="password" id="newPassword" placeholder="Create a password" onkeypress="handleLoginKeyPress(event, 'new')">
                    </div>
                    <div class="input-group">
                        <label>Supported Teams (up to 2)</label>
                        <div class="team-flags-picker" id="registerTeamsPicker"></div>
                    </div>
                    <button onclick="registerNewUser()">Create Account</button>
                </div> -->
            </div>
        </div>

        <!-- Password Reset Modal -->
        <div id="passwordResetModal" class="modal hidden">
            <div class="modal-content">
                <h2 style="font-family: 'Bebas Neue', cursive; font-size: 2rem; color: var(--bright-gold); margin-bottom: 1.5rem; letter-spacing: 0.1em;">Password Reset Required</h2>
                <p style="margin-bottom: 1.5rem;">Your password has been reset by an administrator. Please enter a new password to continue.</p>
                <div class="input-group">
                    <label for="newPasswordReset">New Password</label>
                    <input type="password" id="newPasswordReset" placeholder="Enter new password" onkeypress="handlePasswordResetKeyPress(event)">
                </div>
                <div class="input-group">
                    <label for="confirmPasswordReset">Confirm Password</label>
                    <input type="password" id="confirmPasswordReset" placeholder="Confirm new password" onkeypress="handlePasswordResetKeyPress(event)">
                </div>
                <button onclick="submitPasswordReset()">Set New Password</button>
                <button class="btn-cancel" onclick="cancelPasswordReset()">Cancel</button>
            </div>
        </div>

        <!-- Main App View -->
        <div id="appView" class="hidden">
            <div class="app-header">
                <div class="theme-selector">
                    <label for="themeSelect">Theme:</label>
                    <select id="themeSelect" onchange="changeTheme(this.value)">
                        <option value="classic">Classic</option>
                        <option value="retro">Teletext</option>
                        <option value="dark">Dark Mode</option>
                    </select>
                </div>
                <div class="user-info">
                    <div class="username" id="currentUser"></div>
                    <button class="logout-btn" id="logoutBtn" onclick="logout()">Logout</button>
                </div>
            </div>

            <div class="tabs">
                <button class="tab" onclick="showTab('predictions')">My Predictions</button>
                <button class="tab active" onclick="showTab('summary')">Match Summary</button>
            </div>
            
            <div class="admin-tabs-section admin-only hidden">
                <div class="admin-tabs-label">Admin Functions</div>
                <div class="tabs admin-tabs">
                    <button class="tab" onclick="showTab('competitors')">Competitor Management</button>
                    <button class="tab" onclick="showTab('results')">Fixture Setup</button>
                    <button class="tab" onclick="showTab('recovery')">Database Recovery</button>
                </div>
            </div>

            <!-- Predictions Tab -->
            <div id="predictionsTab" class="prediction-section hidden" style="margin-top: 2rem;">
                <div id="matchesContainer"></div>

                <div class="tries-section" id="triesSection">
                    <h3>Total Tournament Tries</h3>
                    <p style="margin-bottom: 0.75rem; font-size: 0.95rem; opacity: 0.8;">Predict the total tries scored across all matches</p>
                    <input type="number" class="tries-input" id="totalTries" min="0" placeholder="000">
                </div>
            </div>

            <!-- Summary Tab -->
            <div id="summaryTab" style="margin-top: 2rem;">
                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 10px; border: 2px solid var(--gold); margin-bottom: 2rem;">
                    <h2 style="font-family: 'Bebas Neue', cursive; font-size: 2.5rem; color: var(--bright-gold); margin-bottom: 1rem; letter-spacing: 0.1em;">Match Summary</h2>

                    <!-- Filters -->
                    <div class="summary-filters">
                        <button class="filter-btn active" onclick="filterMatches('all')">All Matches</button>
                        <button class="filter-btn" onclick="filterMatches('completed')">Completed Only</button>
                        <div class="round-filter-group">
                            <button class="filter-btn" onclick="filterMatches('round')">Filter By Round</button>
                            <span class="round-divider"></span>
                            <select id="roundSelect" class="round-select" onchange="onRoundSelectChange()">
                            </select>
                        </div>
                        <button class="export-btn" onclick="exportToPDF()" title="Export to PDF">
                            <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 7V3.5L18.5 9H13zM6 20V4h6v6h6v10H6z"/></svg>
                            Export
                        </button>
                    </div>
                </div>

                <div id="summaryContainer"></div>

                <!-- Stats and Tips at bottom -->
                <div style="margin-top: 3rem;">
                    <!-- Estimated Tries Stats -->
                    <div id="triesStatsContainer" class="tries-stats-box"></div>

                    <!-- Trev's Tips -->
                    <div id="trevsTipsContainer" class="trevs-tips-box"></div>
                </div>
            </div>

            <!-- All Predictions Tab -->
            <div id="allPredictionsTab" class="predictions-grid hidden">
                <div id="allPredictionsContainer"></div>
            </div>

            <!-- Competitor Management Tab (Admin Only) -->
            <div id="competitorsTab" class="prediction-section hidden" style="margin-top: 2rem;">
                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 10px; border: 2px solid var(--gold); margin-bottom: 2rem;">
                    <h2 style="font-family: 'Bebas Neue', cursive; font-size: 2rem; color: var(--bright-gold); margin-bottom: 1rem; letter-spacing: 0.1em;">Competitor Management</h2>
                    <p style="margin-bottom: 1rem;">Manage competitor accounts - edit details or remove users</p>
                </div>

                <div id="competitorManagementContainer"></div>
            </div>

            <!-- Fixture Setup Tab (Admin Only) -->
            <div id="resultsTab" class="prediction-section hidden" style="margin-top: 2rem;">
                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 10px; border: 2px solid var(--gold); margin-bottom: 2rem;">
                    <h2 style="font-family: 'Bebas Neue', cursive; font-size: 2rem; color: var(--bright-gold); margin-bottom: 1rem; letter-spacing: 0.1em;">Fixture Setup</h2>
                    <p style="margin-bottom: 1rem;">Manage fixtures, enter match details and results. Changes save automatically.</p>
                </div>

                <!-- Lock Predictions Toggle -->
                <div class="lock-toggle">
                    <label>
                        <strong style="color: var(--gold);">LOCK PREDICTIONS</strong>
                        <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 0.3rem;">When enabled, competitors cannot change their predictions</p>
                    </label>
                    <div id="lockToggle" class="toggle-switch" onclick="togglePredictionsLock()"></div>
                </div>

                <div class="results-table-container">
                    <table class="results-table" id="adminMatchesTable">
                        <thead>
                            <tr>
                                <th>Rnd</th>
                                <th>Date</th>
                                <th>Time</th>
                                <th>Home Team</th>
                                <th>Score</th>
                                <th>Tries</th>
                                <th></th>
                                <th>Away Team</th>
                                <th>Score</th>
                                <th>Tries</th>
                                <th>Joker</th>
                                <th>Scores Captured</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="adminMatchesContainer"></tbody>
                    </table>
                </div>
                
                <div style="margin-top: 1.5rem; text-align: center; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                    <button class="btn-small btn-success" onclick="addNewMatch()" style="padding: 0.75rem 2rem;">+ Add New Fixture</button>
                    <button class="btn-small" onclick="showBulkImport()" style="padding: 0.75rem 2rem; background: var(--accent-blue);">Bulk Import</button>
                    <button class="btn-small btn-danger" onclick="clearAllFixtures()" style="padding: 0.75rem 2rem;">Clear All Fixtures</button>
                </div>

                <!-- Bulk Import Modal -->
                <div id="bulkImportModal" class="modal hidden">
                    <div class="modal-content" style="max-width: 600px;">
                        <h2 style="font-family: 'Bebas Neue', cursive; font-size: 2rem; color: var(--bright-gold); margin-bottom: 1rem; letter-spacing: 0.1em;">Bulk Import Fixtures</h2>
                        <p style="margin-bottom: 1rem;">Enter one fixture per line in the format:</p>
                        <p style="margin-bottom: 1rem; font-family: monospace; background: rgba(0,0,0,0.3); padding: 0.5rem; border-radius: 5px;">Round, DD/MM/YYYY, HH:MM, Home Team, Away Team</p>
                        <p style="margin-bottom: 1rem; font-size: 0.9rem; opacity: 0.8;">Example:<br>
                        <span style="font-family: monospace;">1, 01/02/2026, 14:30, England, France</span><br>
                        <span style="font-family: monospace;">1, 01/02/2026, 17:00, Ireland, Wales</span><br>
                        <span style="font-family: monospace;">2, 08/02/2026, 14:30, France, Ireland</span></p>
                        <textarea id="bulkImportData" rows="10" style="width: 100%; padding: 1rem; background: rgba(255,255,255,0.1); border: 2px solid rgba(212,175,55,0.3); color: var(--white); font-family: monospace; font-size: 0.9rem; border-radius: 5px; resize: vertical;" placeholder="1, 01/02/2026, 14:30, England, France&#10;1, 01/02/2026, 17:00, Ireland, Wales&#10;2, 08/02/2026, 14:30, France, Ireland"></textarea>
                        <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: flex-end;">
                            <button class="btn-cancel" onclick="closeBulkImport()">Cancel</button>
                            <button onclick="processBulkImport()">Import Fixtures</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Database Recovery Tab (Admin Only) -->
            <div id="recoveryTab" class="prediction-section hidden" style="margin-top: 4rem;">
                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 10px; border: 2px solid var(--gold); margin-bottom: 2rem;">
                    <h2 style="font-family: 'Bebas Neue', cursive; font-size: 2rem; color: var(--bright-gold); margin-bottom: 1rem; letter-spacing: 0.1em;">Database Recovery</h2>
                    <p style="margin-bottom: 1rem;">Copy the SQL below and run it in your Supabase SQL Editor to recreate the database with all current data.</p>
                </div>

                <div class="recovery-section">
                    <div class="recovery-card">
                        <h3>Database SQL Export</h3>
                        <div style="margin-bottom: 1rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="checkbox" id="includeDataCheckbox" checked onchange="updateRecoverySQL()" style="width: 18px; height: 18px; cursor: pointer;">
                                <span>Include current data (users, predictions, settings)</span>
                            </label>
                        </div>
                        <p id="recoveryDescription">This SQL will recreate all tables and restore:</p>
                        <ul id="recoveryList" style="margin: 0.5rem 0 1rem 1.5rem; line-height: 1.6;">
                            <li>All matches and fixtures</li>
                            <li>All user accounts (usernames, password hashes)</li>
                            <li>All predictions</li>
                            <li>Admin usernames list</li>
                            <li>App settings</li>
                        </ul>
                        <pre class="sql-preview" id="sqlPreview"></pre>
                        <button class="btn-small" onclick="copySqlToClipboard()" style="margin-top: 1rem;">Copy SQL to Clipboard</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 2026 Six Nations fixtures (kick-off times in GMT)
        const matches = [
            // Round 1
            { id: 1, round: 1, date: 'Thu, Feb 5', time: '20:10', team1: 'France', team2: 'Ireland', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 2, round: 1, date: 'Sat, Feb 7', time: '14:10', team1: 'Italy', team2: 'Scotland', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 3, round: 1, date: 'Sat, Feb 7', time: '16:40', team1: 'England', team2: 'Wales', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            // Round 2
            { id: 4, round: 2, date: 'Sat, Feb 14', time: '14:10', team1: 'Ireland', team2: 'Italy', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 5, round: 2, date: 'Sat, Feb 14', time: '16:40', team1: 'Scotland', team2: 'England', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 6, round: 2, date: 'Sun, Feb 15', time: '15:10', team1: 'Wales', team2: 'France', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            // Round 3
            { id: 7, round: 3, date: 'Sat, Feb 21', time: '14:10', team1: 'England', team2: 'Ireland', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 8, round: 3, date: 'Sat, Feb 21', time: '16:40', team1: 'Wales', team2: 'Scotland', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 9, round: 3, date: 'Sun, Feb 22', time: '15:10', team1: 'France', team2: 'Italy', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            // Round 4
            { id: 10, round: 4, date: 'Fri, Mar 6', time: '20:10', team1: 'Ireland', team2: 'Wales', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 11, round: 4, date: 'Sat, Mar 7', time: '14:10', team1: 'Scotland', team2: 'France', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 12, round: 4, date: 'Sat, Mar 7', time: '16:40', team1: 'Italy', team2: 'England', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            // Round 5
            { id: 13, round: 5, date: 'Sat, Mar 14', time: '14:10', team1: 'Ireland', team2: 'Scotland', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 14, round: 5, date: 'Sat, Mar 14', time: '16:40', team1: 'Wales', team2: 'Italy', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false },
            { id: 15, round: 5, date: 'Sat, Mar 14', time: '20:10', team1: 'France', team2: 'England', actualScore1: null, actualScore2: null, actualTries1: null, actualTries2: null, jokerEligible: false }
        ];

        // Country flags mapping
        const countryFlags = {
            'England': '',
            'France': '',
            'Ireland': '',
            'Italy': '',
            'Scotland': '',
            'Wales': ''
        };

        // Helper function to get flag for a team
        function getFlag(team) {
            return countryFlags[team] || '';
        }

        // Render a team flags picker into a container
        function renderTeamFlagsPicker(containerId, selectedTeams) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const teams = Object.keys(countryFlags);
            container.innerHTML = teams.map(team => {
                const isSelected = selectedTeams && selectedTeams.includes(team);
                return `<div class="team-flag-option ${isSelected ? 'selected' : ''}" data-team="${team}" onclick="toggleTeamFlag(this, '${containerId}')">
                    <span class="flag-emoji">${getFlag(team)}</span>
                    <span>${team}</span>
                </div>`;
            }).join('');
        }

        // Toggle a team flag selection (max 2)
        function toggleTeamFlag(el, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const isSelected = el.classList.contains('selected');
            if (isSelected) {
                el.classList.remove('selected');
            } else {
                const selectedCount = container.querySelectorAll('.team-flag-option.selected').length;
                if (selectedCount >= 2) return; // Max 2
                el.classList.add('selected');
            }
        }

        // Get selected teams from a picker
        function getSelectedTeams(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return [];
            return Array.from(container.querySelectorAll('.team-flag-option.selected')).map(el => el.dataset.team);
        }

        // Get flag emojis string for display next to a user's name
        function getUserFlags(username) {
            const teams = users[username] && users[username].supportedTeams ? users[username].supportedTeams : [];
            if (teams.length === 0) return '';
            return '<span class="supported-team-flags">' + teams.map(t => getFlag(t)).join('') + '</span> ';
        }

        // Helper function to convert string to Title Case (Camel Case for display)
        function toTitleCase(str) {
            if (!str) return '';
            return str.toLowerCase().split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        // Helper function to get formatted display name
        function getDisplayName(username) {
            if (!users[username]) return username;
            const nickname = users[username].nickname || username;
            return toTitleCase(nickname);
        }

        // Simple hash function for password storage (SHA-256)
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }

        // Check if a password matches a hash
        async function verifyPassword(password, hash) {
            const passwordHash = await hashPassword(password);
            return passwordHash === hash;
        }

        // ============================================
        // SUPABASE CONFIGURATION
        // Replace these with your Supabase project details
        // ============================================
        const SUPABASE_URL = 'https://tzspmhmyhcbogwqefvfc.supabase.co';  // e.g., 'https://xxxxx.supabase.co'
        const SUPABASE_ANON_KEY = 'sb_publishable_LDr2Tvnosv-H38JuWV5B0g_aKKA4NV1';  // Your anon/public key
        
        // Initialize Supabase client
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ============================================
        // STORAGE ABSTRACTION LAYER (Supabase)
        // ============================================
        const Storage = {
            // Users - get all users as object keyed by username
            getUsers: async () => {
                const { data, error } = await supabaseClient
                    .from('users')
                    .select('*');
                
                if (error) {
                    console.error('Error fetching users:', error);
                    return {};
                }
                
                // Convert array to object keyed by username
                const usersObj = {};
                data.forEach(user => {
                    usersObj[user.username] = {
                        nickname: user.nickname,
                        passwordHash: user.password_hash,
                        totalTries: user.total_tries,
                        jokerMatchId: user.joker_match_id,
                        supportedTeams: user.supported_teams ? user.supported_teams.split(',') : [],
                        predictions: {}  // Will be populated separately
                    };
                });
                
                // Fetch predictions for all users
                const { data: predictions, error: predError } = await supabaseClient
                    .from('predictions')
                    .select('*');
                
                if (!predError && predictions) {
                    // Map user_id to username
                    const userIdToUsername = {};
                    data.forEach(user => {
                        userIdToUsername[user.id] = user.username;
                    });
                    
                    predictions.forEach(pred => {
                        const username = userIdToUsername[pred.user_id];
                        if (username && usersObj[username]) {
                            usersObj[username].predictions[pred.match_id] = {
                                team1: pred.team1_score,
                                team2: pred.team2_score
                            };
                        }
                    });
                }
                
                return usersObj;
            },
            
            // Save a single user (for registration/updates)
            saveUser: async (username, userData) => {
                // Check if user exists
                const { data: existing } = await supabaseClient
                    .from('users')
                    .select('id')
                    .eq('username', username)
                    .single();
                
                if (existing) {
                    // Update existing user
                    const { error } = await supabaseClient
                        .from('users')
                        .update({
                            nickname: userData.nickname,
                            password_hash: userData.passwordHash,
                            total_tries: userData.totalTries,
                            joker_match_id: userData.jokerMatchId,
                            supported_teams: userData.supportedTeams && userData.supportedTeams.length > 0 ? userData.supportedTeams.join(',') : null
                        })
                        .eq('username', username);
                    
                    if (error) console.error('Error updating user:', error);
                } else {
                    // Insert new user
                    const { error } = await supabaseClient
                        .from('users')
                        .insert({
                            username: username,
                            nickname: userData.nickname,
                            password_hash: userData.passwordHash,
                            total_tries: userData.totalTries,
                            joker_match_id: userData.jokerMatchId,
                            supported_teams: userData.supportedTeams && userData.supportedTeams.length > 0 ? userData.supportedTeams.join(',') : null
                        });
                    
                    if (error) console.error('Error inserting user:', error);
                }
            },

            // Rename a user (update username in DB)
            renameUser: async (oldUsername, newUsername) => {
                const { error } = await supabaseClient
                    .from('users')
                    .update({ username: newUsername })
                    .eq('username', oldUsername);

                if (error) console.error('Error renaming user:', error);
            },

            // Save predictions for a user
            savePredictions: async (username, predictions, totalTries) => {
                // Get user ID
                const { data: user } = await supabaseClient
                    .from('users')
                    .select('id')
                    .eq('username', username)
                    .single();
                
                if (!user) {
                    console.error('User not found:', username);
                    return;
                }
                
                // Update total tries
                await supabaseClient
                    .from('users')
                    .update({ total_tries: totalTries })
                    .eq('id', user.id);
                
                // Upsert predictions
                for (const [matchId, pred] of Object.entries(predictions)) {
                    const { error } = await supabaseClient
                        .from('predictions')
                        .upsert({
                            user_id: user.id,
                            match_id: parseInt(matchId),
                            team1_score: pred.team1,
                            team2_score: pred.team2,
                            updated_at: new Date().toISOString()
                        }, {
                            onConflict: 'user_id,match_id'
                        });
                    
                    if (error) console.error('Error saving prediction:', error);
                }
            },
            
            // Delete a user
            deleteUser: async (username) => {
                const { error } = await supabaseClient
                    .from('users')
                    .delete()
                    .eq('username', username);
                
                if (error) console.error('Error deleting user:', error);
            },
            
            // Matches/Fixtures
            getMatches: async () => {
                const { data, error } = await supabaseClient
                    .from('matches')
                    .select('*')
                    .order('id');
                
                if (error) {
                    console.error('Error fetching matches:', error);
                    return null;
                }
                
                if (!data || data.length === 0) return null;
                
                // Convert to app format
                return data.map(m => ({
                    id: m.id,
                    round: m.round,
                    date: m.date,
                    time: m.time,
                    team1: m.team1,
                    team2: m.team2,
                    actualScore1: m.actual_score1,
                    actualScore2: m.actual_score2,
                    actualTries1: m.actual_tries1,
                    actualTries2: m.actual_tries2,
                    jokerEligible: m.joker_eligible || false
                }));
            },

            saveMatches: async (matchesData) => {
                // Delete all existing matches and re-insert
                await supabaseClient.from('matches').delete().neq('id', 0);
                
                const rows = matchesData.map(m => ({
                    id: m.id,
                    round: m.round,
                    date: m.date,
                    time: m.time,
                    team1: m.team1,
                    team2: m.team2,
                    actual_score1: m.actualScore1,
                    actual_score2: m.actualScore2,
                    actual_tries1: m.actualTries1,
                    actual_tries2: m.actualTries2,
                    joker_eligible: m.jokerEligible || false
                }));

                const { error } = await supabaseClient.from('matches').insert(rows);
                if (error) console.error('Error saving matches:', error);
            },
            
            // Admin usernames
            getAdminUsernames: async () => {
                const { data, error } = await supabaseClient
                    .from('admin_usernames')
                    .select('username');

                if (error) {
                    console.error('Error fetching admin usernames:', error);
                    return [];
                }

                return data.map(row => row.username);
            },

            saveAdminUsernames: async (usernames) => {
                // Delete all and re-insert
                await supabaseClient.from('admin_usernames').delete().neq('username', '');

                if (usernames.length > 0) {
                    const rows = usernames.map(username => ({ username }));
                    const { error } = await supabaseClient.from('admin_usernames').insert(rows);
                    if (error) console.error('Error saving admin usernames:', error);
                }
            },
            
            // App settings
            getSettings: async () => {
                const { data, error } = await supabaseClient
                    .from('settings')
                    .select('*');
                
                if (error || !data || data.length === 0) {
                    return { predictionsLocked: false };
                }
                
                const settings = {};
                data.forEach(row => {
                    if (row.key === 'predictions_locked') {
                        settings.predictionsLocked = row.value === 'true' || row.value === true;
                    }
                });
                
                return settings;
            },
            
            saveSettings: async (settings) => {
                const { error } = await supabaseClient
                    .from('settings')
                    .upsert({
                        key: 'predictions_locked',
                        value: settings.predictionsLocked ? 'true' : 'false'
                    }, {
                        onConflict: 'key'
                    });
                
                if (error) console.error('Error saving settings:', error);
            }
        };

        // In-memory state (loaded from storage on init)
        let users = {};
        let currentUsername = null;
        let adminUsernames = [];
        let appSettings = { predictionsLocked: false };
        let isGuest = false;

        // Loading state
        let isLoading = true;

        // Cookie helper functions
        function setCookie(name, value, days = 365) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${encodeURIComponent(value)};expires=${expires.toUTCString()};path=/;SameSite=Strict`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
            }
            return null;
        }

        function deleteCookie(name) {
            document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;`;
        }

        // Initialize data from supabaseClient
        async function initializeData() {
            try {
                // Show loading indicator
                showLoadingScreen();
                
                // Load all data in parallel
                const [loadedUsers, loadedAdmins, loadedSettings, loadedMatches] = await Promise.all([
                    Storage.getUsers(),
                    Storage.getAdminUsernames(),
                    Storage.getSettings(),
                    Storage.getMatches()
                ]);
                
                users = loadedUsers;
                adminUsernames = loadedAdmins;
                appSettings = loadedSettings;
                
                // Load matches from database or use defaults
                if (loadedMatches && loadedMatches.length > 0) {
                    matches.length = 0;
                    loadedMatches.forEach(m => matches.push(m));
                }
                
                isLoading = false;
                hideLoadingScreen();
                
            } catch (error) {
                console.error('Error initializing data:', error);
                isLoading = false;
                hideLoadingScreen();
                alert('Error connecting to database. Please check your connection and refresh.');
            }
        }

        function showLoadingScreen() {
            const loader = document.getElementById('loadingScreen');
            if (loader) loader.classList.remove('hidden');
        }

        function hideLoadingScreen() {
            const loader = document.getElementById('loadingScreen');
            if (loader) loader.classList.add('hidden');
        }

        // Check if current user is admin
        function isCurrentUserAdmin() {
            if (!currentUsername || !users[currentUsername]) return false;
            return adminUsernames.includes(currentUsername);
        }

        // Initialize app
        function init() {
            renderMatches();
            renderAdminMatches();
        }

        // Toggle predictions lock
        async function togglePredictionsLock() {
            appSettings.predictionsLocked = !appSettings.predictionsLocked;
            await Storage.saveSettings(appSettings);
            updateLockToggleUI();
            renderMatches(); // Re-render to show/hide inputs
        }

        // Update lock toggle UI
        function updateLockToggleUI() {
            const toggle = document.getElementById('lockToggle');
            if (toggle) {
                if (appSettings.predictionsLocked) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }
        }

        // Render admin matches for entering results
        function renderAdminMatches() {
            const container = document.getElementById('adminMatchesContainer');
            const teams = ['England', 'France', 'Ireland', 'Italy', 'Scotland', 'Wales'];
            
            container.innerHTML = matches.map(match => {
                // Parse existing date to get ISO format for date input
                const dateForInput = parseDateForInput(match.date);
                
                return `
                <tr>
                    <td>
                        <input type="number" id="round-${match.id}" value="${match.round}" min="1" max="10" style="width: 50px;" onblur="autoSaveResults()">
                    </td>
                    <td>
                        <input type="date" id="date-${match.id}" value="${dateForInput}" style="width: 140px;" onchange="autoSaveResults()">
                    </td>
                    <td>
                        <input type="time" id="time-${match.id}" value="${match.time || ''}" style="width: 100px;" onchange="autoSaveResults()">
                    </td>
                    <td>
                        <select id="team1-select-${match.id}" onchange="autoSaveResults()">
                            ${teams.map(t => `<option value="${t}" ${match.team1 === t ? 'selected' : ''}>${getFlag(t)} ${t}</option>`).join('')}
                        </select>
                    </td>
                    <td>
                        <input type="number" id="actual-team1-${match.id}" min="0" placeholder="-" value="${match.actualScore1 !== null ? match.actualScore1 : ''}" onblur="autoSaveResults()">
                    </td>
                    <td>
                        <input type="number" id="actual-tries1-${match.id}" min="0" placeholder="-" value="${match.actualTries1 !== null ? match.actualTries1 : ''}" onblur="autoSaveResults()">
                    </td>
                    <td class="vs-cell">vs</td>
                    <td>
                        <select id="team2-select-${match.id}" onchange="autoSaveResults()">
                            ${teams.map(t => `<option value="${t}" ${match.team2 === t ? 'selected' : ''}>${getFlag(t)} ${t}</option>`).join('')}
                        </select>
                    </td>
                    <td>
                        <input type="number" id="actual-team2-${match.id}" min="0" placeholder="-" value="${match.actualScore2 !== null ? match.actualScore2 : ''}" onblur="autoSaveResults()">
                    </td>
                    <td>
                        <input type="number" id="actual-tries2-${match.id}" min="0" placeholder="-" value="${match.actualTries2 !== null ? match.actualTries2 : ''}" onblur="autoSaveResults()">
                    </td>
                    <td style="text-align: center;">
                        <input type="checkbox" id="joker-eligible-${match.id}" ${match.jokerEligible ? 'checked' : ''} onchange="autoSaveResults()">
                    </td>
                    <td class="saved-cell" id="result-saved-${match.id}"></td>
                    <td>
                        <button class="btn-small btn-danger" onclick="deleteMatch(${match.id})" style="padding: 0.3rem 0.6rem; font-size: 0.75rem;"></button>
                    </td>
                </tr>
            `}).join('');
            
            // Update saved indicators
            updateResultSavedIndicators();
        }

        // Parse a display date (e.g., "Sat, Feb 7") to ISO format for date input (e.g., "2026-02-07")
        function parseDateForInput(dateStr) {
            if (!dateStr || dateStr === 'TBD') return '';
            // Already ISO format
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return dateStr;
            
            const months = {
                'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
                'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
                'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'
            };
            
            // Try to parse "Day, Mon DD" format
            const match = dateStr.match(/(\w+),?\s*(\w+)\s+(\d+)/);
            if (match) {
                const month = months[match[2]];
                const day = match[3].padStart(2, '0');
                if (month) {
                    return `2026-${month}-${day}`;
                }
            }
            
            return '';
        }

        // Format ISO date (e.g., "2026-02-07") to display format (e.g., "Sat, Feb 7")
        function formatDateForDisplay(isoDate) {
            if (!isoDate) return 'TBD';
            
            const date = new Date(isoDate + 'T12:00:00');
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            const dayName = days[date.getDay()];
            const monthName = months[date.getMonth()];
            const dayNum = date.getDate();
            
            return `${dayName}, ${monthName} ${dayNum}`;
        }

        // Add a new match
        async function addNewMatch() {
            // Find the highest existing ID
            const maxId = matches.length > 0 ? Math.max(...matches.map(m => m.id)) : 0;
            // Find the highest round
            const maxRound = matches.length > 0 ? Math.max(...matches.map(m => m.round)) : 0;
            
            const newMatch = {
                id: maxId + 1,
                round: maxRound,
                date: 'TBD',
                time: '15:00',
                team1: 'England',
                team2: 'France',
                actualScore1: null,
                actualScore2: null,
                actualTries1: null,
                actualTries2: null,
                jokerEligible: false
            };

            matches.push(newMatch);
            await Storage.saveMatches(matches);
            renderAdminMatches();
            renderMatches();
        }

        // Delete a match
        async function deleteMatch(matchId) {
            const match = matches.find(m => m.id === matchId);
            if (!match) return;
            
            if (!confirm(`Are you sure you want to delete the fixture: ${match.team1} vs ${match.team2}?`)) {
                return;
            }
            
            // Remove the match
            const index = matches.findIndex(m => m.id === matchId);
            if (index > -1) {
                matches.splice(index, 1);
                await Storage.saveMatches(matches);
                renderAdminMatches();
                renderMatches();
                updateLeaderboard();
            }
        }

        // Clear all fixtures
        async function clearAllFixtures() {
            if (!confirm('Are you sure you want to remove ALL fixtures? This cannot be undone.')) {
                return;
            }
            if (!confirm('This will delete all match data. Are you really sure?')) {
                return;
            }
            
            matches.length = 0;
            await Storage.saveMatches(matches);
            renderAdminMatches();
            renderMatches();
            showSummary();
            alert('All fixtures have been removed.');
        }

        // Show bulk import modal
        function showBulkImport() {
            document.getElementById('bulkImportModal').classList.remove('hidden');
            document.getElementById('bulkImportData').value = '';
            document.getElementById('bulkImportData').focus();
        }

        // Close bulk import modal
        function closeBulkImport() {
            document.getElementById('bulkImportModal').classList.add('hidden');
        }

        // Process bulk import data
        async function processBulkImport() {
            const data = document.getElementById('bulkImportData').value.trim();
            
            if (!data) {
                alert('Please enter fixture data to import.');
                return;
            }
            
            const lines = data.split('\n').filter(line => line.trim());
            const newFixtures = [];
            const errors = [];
            
            // Find the highest existing ID
            const maxId = matches.length > 0 ? Math.max(...matches.map(m => m.id)) : 0;
            let nextId = maxId + 1;
            
            lines.forEach((line, index) => {
                const parts = line.split(',').map(p => p.trim());
                
                if (parts.length < 5) {
                    errors.push(`Line ${index + 1}: Not enough fields (need round, date, time, home team, away team)`);
                    return;
                }
                
                const [roundStr, dateStr, timeStr, homeTeam, awayTeam] = parts;
                
                // Parse round
                const round = parseInt(roundStr);
                if (isNaN(round) || round < 1) {
                    errors.push(`Line ${index + 1}: Invalid round number "${roundStr}"`);
                    return;
                }
                
                // Parse date (DD/MM/YYYY)
                const dateMatch = dateStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                if (!dateMatch) {
                    errors.push(`Line ${index + 1}: Invalid date format "${dateStr}" (use DD/MM/YYYY)`);
                    return;
                }
                
                const day = parseInt(dateMatch[1]);
                const month = parseInt(dateMatch[2]);
                const year = parseInt(dateMatch[3]);
                
                // Validate date
                if (month < 1 || month > 12 || day < 1 || day > 31) {
                    errors.push(`Line ${index + 1}: Invalid date "${dateStr}"`);
                    return;
                }
                
                // Parse time (HH:MM)
                const timeMatch = timeStr.match(/(\d{1,2}):(\d{2})/);
                if (!timeMatch) {
                    errors.push(`Line ${index + 1}: Invalid time format "${timeStr}" (use HH:MM)`);
                    return;
                }
                
                const hours = parseInt(timeMatch[1]);
                const mins = parseInt(timeMatch[2]);
                
                if (hours < 0 || hours > 23 || mins < 0 || mins > 59) {
                    errors.push(`Line ${index + 1}: Invalid time "${timeStr}"`);
                    return;
                }
                
                // Normalize team names
                const team1 = normalizeTeamName(homeTeam);
                const team2 = normalizeTeamName(awayTeam);
                
                if (!team1) {
                    errors.push(`Line ${index + 1}: Unknown home team "${homeTeam}"`);
                    return;
                }
                
                if (!team2) {
                    errors.push(`Line ${index + 1}: Unknown away team "${awayTeam}"`);
                    return;
                }
                
                if (team1 === team2) {
                    errors.push(`Line ${index + 1}: Home and away teams cannot be the same`);
                    return;
                }
                
                // Format date for display
                const date = new Date(year, month - 1, day);
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const displayDate = `${days[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}`;
                
                // Format time
                const displayTime = `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
                
                newFixtures.push({
                    id: nextId++,
                    round: round,
                    date: displayDate,
                    time: displayTime,
                    team1: team1,
                    team2: team2,
                    actualScore1: null,
                    actualScore2: null,
                    actualTries1: null,
                    actualTries2: null,
                    jokerEligible: false
                });
            });
            
            // Show errors if any
            if (errors.length > 0) {
                alert('Import errors:\n\n' + errors.join('\n'));
                return;
            }
            
            if (newFixtures.length === 0) {
                alert('No valid fixtures found to import.');
                return;
            }
            
            // Confirm and import
            const action = matches.length > 0 
                ? confirm(`Import ${newFixtures.length} fixtures?\n\nClick OK to ADD to existing fixtures, or Cancel then clear fixtures first to replace them.`)
                : true;
            
            if (!action) return;
            
            // Add new fixtures
            newFixtures.forEach(f => matches.push(f));
            
            await Storage.saveMatches(matches);
            closeBulkImport();
            renderAdminMatches();
            renderMatches();
            showSummary();
            
            alert(`Successfully imported ${newFixtures.length} fixtures!`);
        }

        // Helper to normalize team names from various formats
        function normalizeTeamName(name) {
            const normalized = name.toLowerCase().trim();
            if (normalized.includes('england') || normalized === 'eng') return 'England';
            if (normalized.includes('france') || normalized === 'fra') return 'France';
            if (normalized.includes('ireland') || normalized === 'ire') return 'Ireland';
            if (normalized.includes('italy') || normalized.includes('italia') || normalized === 'ita') return 'Italy';
            if (normalized.includes('scotland') || normalized === 'sco') return 'Scotland';
            if (normalized.includes('wales') || normalized === 'wal') return 'Wales';
            return null;
        }

        // Auto-save match results on blur
        async function autoSaveResults() {
            matches.forEach(match => {
                // Get all editable fields
                const roundEl = document.getElementById(`round-${match.id}`);
                const team1SelectEl = document.getElementById(`team1-select-${match.id}`);
                const team2SelectEl = document.getElementById(`team2-select-${match.id}`);
                const dateEl = document.getElementById(`date-${match.id}`);
                const timeEl = document.getElementById(`time-${match.id}`);
                const team1ScoreEl = document.getElementById(`actual-team1-${match.id}`);
                const team2ScoreEl = document.getElementById(`actual-team2-${match.id}`);
                const team1TriesEl = document.getElementById(`actual-tries1-${match.id}`);
                const team2TriesEl = document.getElementById(`actual-tries2-${match.id}`);
                const jokerEligibleEl = document.getElementById(`joker-eligible-${match.id}`);

                // Update fixture details
                if (roundEl) match.round = parseInt(roundEl.value) || 1;
                if (jokerEligibleEl) match.jokerEligible = jokerEligibleEl.checked;
                if (team1SelectEl) match.team1 = team1SelectEl.value;
                if (team2SelectEl) match.team2 = team2SelectEl.value;
                
                // Convert date input to display format
                if (dateEl) {
                    if (dateEl.value) {
                        match.date = formatDateForDisplay(dateEl.value);
                    } else if (!match.date || match.date === 'TBD') {
                        match.date = 'TBD';
                    }
                }
                
                // Store time in HH:MM format
                if (timeEl && timeEl.value) {
                    match.time = timeEl.value;
                } else if (timeEl) {
                    match.time = 'TBD';
                }
                
                if (!team1ScoreEl || !team2ScoreEl) return;
                
                const team1Score = team1ScoreEl.value;
                const team2Score = team2ScoreEl.value;
                const team1Tries = team1TriesEl ? team1TriesEl.value : '';
                const team2Tries = team2TriesEl ? team2TriesEl.value : '';
                
                // Only save scores if both scores AND both tries are entered
                if (team1Score !== '' && team2Score !== '' && team1Tries !== '' && team2Tries !== '') {
                    match.actualScore1 = parseInt(team1Score);
                    match.actualScore2 = parseInt(team2Score);
                    match.actualTries1 = parseInt(team1Tries);
                    match.actualTries2 = parseInt(team2Tries);
                } else {
                    // Clear the result if incomplete
                    match.actualScore1 = null;
                    match.actualScore2 = null;
                    match.actualTries1 = null;
                    match.actualTries2 = null;
                }
            });

            // Save to storage
            await Storage.saveMatches(matches);
            
            // Update saved indicators
            updateResultSavedIndicators();

            // Recalculate all points
            updateLeaderboard();
        }

        // Update the saved tick indicators for match results
        function updateResultSavedIndicators() {
            matches.forEach(match => {
                const indicator = document.getElementById(`result-saved-${match.id}`);
                if (indicator) {
                    const isComplete = match.actualScore1 !== null && 
                                      match.actualScore2 !== null && 
                                      match.actualTries1 !== null && 
                                      match.actualTries2 !== null;
                    if (isComplete) {
                        indicator.textContent = '';
                        indicator.classList.add('visible');
                    } else {
                        indicator.textContent = '';
                        indicator.classList.remove('visible');
                    }
                }
            });
        }

        // Render competitor management table
        function renderCompetitorManagement() {
            const container = document.getElementById('competitorManagementContainer');
            const allUsers = Object.keys(users);
            
            if (allUsers.length === 0) {
                container.innerHTML = '<p style="text-align: center; font-size: 1.2rem; opacity: 0.7;">No competitors registered yet.</p>';
                return;
            }

            const teams = Object.keys(countryFlags);
            const teamOptions = teams.map(t => `<option value="${t}">${getFlag(t)} ${t}</option>`).join('');

            let html = `
                <table class="admin-table">
                    <thead>
                        <tr>
                            <th>Username</th>
                            <th>Display Name</th>
                            <th>Supported Teams</th>
                            <th>Admin</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            allUsers.forEach(username => {
                const user = users[username];
                const isAdmin = adminUsernames.includes(username);
                const safeUsername = username.replace(/'/g, "\\'");
                const needsReset = user.passwordResetRequired ? '<span style="color: #f39c12; font-size: 0.8rem;"> (Reset Required)</span>' : '';
                const userTeams = user.supportedTeams || [];
                html += `
                    <tr id="user-row-${username}">
                        <td><input type="text" id="edit-username-${username}" value="${username}" style="max-width: 150px;">${needsReset}</td>
                        <td><input type="text" id="edit-nickname-${username}" value="${user.nickname || ''}" style="max-width: 150px;"></td>
                        <td>
                            <select id="edit-team1-${username}" style="font-size: 0.85rem; margin-bottom: 0.25rem;">
                                <option value="">None</option>
                                ${teams.map(t => `<option value="${t}" ${userTeams[0] === t ? 'selected' : ''}>${getFlag(t)} ${t}</option>`).join('')}
                            </select><br>
                            <select id="edit-team2-${username}" style="font-size: 0.85rem;">
                                <option value="">None</option>
                                ${teams.map(t => `<option value="${t}" ${userTeams[1] === t ? 'selected' : ''}>${getFlag(t)} ${t}</option>`).join('')}
                            </select>
                        </td>
                        <td>
                            <input type="checkbox" id="edit-admin-${username}" ${isAdmin ? 'checked' : ''} onchange="toggleUserAdmin('${safeUsername}')">
                        </td>
                        <td>
                            <button class="btn-small btn-success" onclick="saveUserChanges('${safeUsername}')">Save</button>
                            <button class="btn-small btn-warning" onclick="resetUserPassword('${safeUsername}')">Reset Password</button>
                            <button class="btn-small btn-danger" onclick="deleteUser('${safeUsername}')">Delete</button>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // Save changes to a user
        async function saveUserChanges(username) {
            const newUsername = document.getElementById(`edit-username-${username}`).value.trim().toLowerCase();
            const nickname = document.getElementById(`edit-nickname-${username}`).value.trim();

            if (!newUsername) {
                alert('Username is required.');
                return;
            }

            if (!/^[a-z0-9]+$/.test(newUsername)) {
                alert('Username can only contain letters and numbers.');
                return;
            }

            if (!nickname) {
                alert('Display name is required.');
                return;
            }

            // Check if new username is taken by another user
            if (newUsername !== username && users[newUsername]) {
                alert('This username is already taken by another user.');
                return;
            }

            // Check if nickname is taken by another user
            const existingUser = Object.keys(users).find(u =>
                u !== username && users[u].nickname && users[u].nickname.toLowerCase() === nickname.toLowerCase()
            );
            if (existingUser) {
                alert('This display name is already taken by another user.');
                return;
            }

            // Read supported teams from dropdowns
            const team1El = document.getElementById(`edit-team1-${username}`);
            const team2El = document.getElementById(`edit-team2-${username}`);
            const team1 = team1El ? team1El.value : '';
            const team2 = team2El ? team2El.value : '';

            if (newUsername !== username) {
                // Username changed - update DB username, re-key local data, update admin list
                await Storage.renameUser(username, newUsername);

                // Update admin usernames list
                const adminIndex = adminUsernames.indexOf(username);
                if (adminIndex !== -1) {
                    adminUsernames[adminIndex] = newUsername;
                    await Storage.saveAdminUsernames(adminUsernames);
                }

                // Re-key in local users object
                users[newUsername] = users[username];
                delete users[username];

                // Update current session if editing self
                if (currentUsername === username) {
                    currentUsername = newUsername;
                    setCookie('rugbyPredictorUser', newUsername);
                }
            }

            users[newUsername].nickname = nickname;
            users[newUsername].supportedTeams = [team1, team2].filter(Boolean);

            await Storage.saveUser(newUsername, users[newUsername]);
            alert('User updated successfully!');

            // Update current user display if editing self
            if (newUsername === currentUsername) {
                document.getElementById('currentUser').textContent = toTitleCase(nickname);
            }

            // Re-render to update row IDs and input IDs
            renderCompetitorManagement();
        }

        // Toggle user admin status
        async function toggleUserAdmin(username) {
            const user = users[username];
            if (!user) return;

            const isCurrentlyAdmin = adminUsernames.includes(username);

            if (isCurrentlyAdmin) {
                // Remove from admins
                adminUsernames = adminUsernames.filter(u => u !== username);
            } else {
                // Add to admins
                adminUsernames.push(username);
            }

            await Storage.saveAdminUsernames(adminUsernames);
        }

        // Delete a user
        async function deleteUser(username) {
            if (!username || !users[username]) {
                alert('User not found.');
                return;
            }
            
            if (username === currentUsername) {
                alert('You cannot delete your own account while logged in.');
                return;
            }

            const displayName = toTitleCase(users[username].nickname || username);
            if (!confirm(`Are you sure you want to delete ${displayName}? This cannot be undone.`)) {
                return;
            }

            // Remove from admin list if they were an admin
            adminUsernames = adminUsernames.filter(u => u !== username);
            await Storage.saveAdminUsernames(adminUsernames);

            delete users[username];
            await Storage.deleteUser(username);
            renderCompetitorManagement();
            updateLeaderboard();
        }

        // Reset a user's password
        async function resetUserPassword(username) {
            if (!username || !users[username]) {
                alert('User not found.');
                return;
            }

            const displayName = toTitleCase(users[username].nickname || username);
            if (!confirm(`Are you sure you want to reset the password for ${displayName}? They will be prompted to create a new password on their next login.`)) {
                return;
            }

            // Set flag to require password reset on next login
            users[username].passwordResetRequired = true;
            await Storage.saveUser(username, users[username]);
            
            alert(`Password reset initiated for ${displayName}. They will be prompted to set a new password on their next login.`);
            renderCompetitorManagement();
        }

        // Variable to track which user is resetting their password
        let passwordResetUsername = null;

        // Show password reset modal
        function showPasswordResetModal(username) {
            passwordResetUsername = username;
            document.getElementById('passwordResetModal').classList.remove('hidden');
            document.getElementById('newPasswordReset').value = '';
            document.getElementById('confirmPasswordReset').value = '';
            document.getElementById('newPasswordReset').focus();
        }

        // Cancel password reset
        function cancelPasswordReset() {
            passwordResetUsername = null;
            document.getElementById('passwordResetModal').classList.add('hidden');
            document.getElementById('newPasswordReset').value = '';
            document.getElementById('confirmPasswordReset').value = '';
        }

        // Handle enter key on password reset form
        function handlePasswordResetKeyPress(event) {
            if (event.key === 'Enter') {
                submitPasswordReset();
            }
        }

        // Submit new password
        async function submitPasswordReset() {
            const newPassword = document.getElementById('newPasswordReset').value;
            const confirmPassword = document.getElementById('confirmPasswordReset').value;

            if (!newPassword || !confirmPassword) {
                alert('Please enter and confirm your new password.');
                return;
            }

            if (newPassword !== confirmPassword) {
                alert('Passwords do not match. Please try again.');
                return;
            }

            if (newPassword.length < 4) {
                alert('Password must be at least 4 characters long.');
                return;
            }

            // Hash the new password
            const passwordHash = await hashPassword(newPassword);

            // Update the user's password hash and clear the reset flag
            users[passwordResetUsername].passwordHash = passwordHash;
            delete users[passwordResetUsername].password; // Remove any legacy plain text password
            users[passwordResetUsername].passwordResetRequired = false;
            await Storage.saveUser(passwordResetUsername, users[passwordResetUsername]);

            // Close modal and log in
            document.getElementById('passwordResetModal').classList.add('hidden');
            
            showLoginFeedback('Password updated successfully! Welcome back, ' + toTitleCase(users[passwordResetUsername].nickname), 'success');
            currentUsername = passwordResetUsername;
            setCookie('rugbyPredictorUser', currentUsername);
            passwordResetUsername = null;

            setTimeout(() => {
                showApp();
            }, 800);
        }

        // Change theme
        async function changeTheme(theme) {
            // Apply theme to document
            if (theme === 'classic') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', theme);
            }
            
            // Save to user's account if logged in
            if (currentUsername && users[currentUsername]) {
                users[currentUsername].theme = theme;
                await Storage.saveUser(currentUsername, users[currentUsername]);
            }
            
            // Update the selector
            const selector = document.getElementById('themeSelect');
            if (selector) {
                selector.value = theme;
            }
        }

        // Load user's saved theme
        function loadUserTheme() {
            if (currentUsername && users[currentUsername] && users[currentUsername].theme) {
                changeTheme(users[currentUsername].theme);
            } else {
                changeTheme('classic');
            }
        }

        // Calculate total actual tries in tournament
        function getTotalActualTries() {
            let total = 0;
            matches.forEach(match => {
                if (match.actualTries1 !== null) total += match.actualTries1;
                if (match.actualTries2 !== null) total += match.actualTries2;
            });
            return total;
        }

        // Show/hide login forms
        function showLoginForm(type) {
            const existingForm = document.getElementById('existingUserForm');
            const newForm = document.getElementById('newUserForm');
            const toggleBtns = document.querySelectorAll('.toggle-btn');
            const feedbackEl = document.getElementById('loginFeedback');

            // Clear feedback
            feedbackEl.classList.add('hidden');
            feedbackEl.className = 'login-feedback hidden';

            // Toggle forms
            if (type === 'existing') {
                existingForm.classList.remove('hidden');
                newForm.classList.add('hidden');
                toggleBtns[0].classList.add('active');
                toggleBtns[1].classList.remove('active');
            } else {
                existingForm.classList.add('hidden');
                newForm.classList.remove('hidden');
                toggleBtns[0].classList.remove('active');
                toggleBtns[1].classList.add('active');
            }
        }

        // Login as guest (view only)
        function loginAsGuest() {
            isGuest = true;
            currentUsername = null;
            showAppAsGuest();
        }

        // Login existing user
        async function loginExisting() {
            const username = document.getElementById('existingUsername').value.trim().toLowerCase();
            const password = document.getElementById('existingPassword').value;
            const feedbackEl = document.getElementById('loginFeedback');

            // Clear previous feedback
            feedbackEl.classList.add('hidden');
            feedbackEl.className = 'login-feedback hidden';

            if (!username || !password) {
                showLoginFeedback('Please enter both username and password', 'error');
                return;
            }

            // Check if user exists
            if (!users[username]) {
                showLoginFeedback('Username not found. Please check and try again.', 'error');
                return;
            }

            // Check if password reset is required
            if (users[username].passwordResetRequired) {
                showPasswordResetModal(username);
                return;
            }

            // Check password - support both hashed and legacy plain text passwords
            let passwordValid = false;
            if (users[username].passwordHash) {
                // New hashed password
                passwordValid = await verifyPassword(password, users[username].passwordHash);
            } else if (users[username].password) {
                // Legacy plain text password - migrate to hash on successful login
                if (users[username].password === password) {
                    passwordValid = true;
                    // Migrate to hashed password
                    users[username].passwordHash = await hashPassword(password);
                    delete users[username].password;
                    await Storage.saveUser(username, users[username]);
                }
            }

            if (!passwordValid) {
                showLoginFeedback('Incorrect password. Please try again.', 'error');
                return;
            }

            // Successful login
            showLoginFeedback('Login successful! Welcome back, ' + toTitleCase(users[username].nickname), 'success');
            currentUsername = username;
            setCookie('rugbyPredictorUser', username);
            setTimeout(() => {
                showApp();
            }, 800);
        }

        // Register new user
        async function registerNewUser() {
            const username = document.getElementById('newUsername').value.trim().toLowerCase();
            const nickname = document.getElementById('nickname').value.trim();
            const password = document.getElementById('newPassword').value;

            // Validation
            if (!username || !nickname || !password) {
                showLoginFeedback('Please fill in all fields', 'error');
                return;
            }

            // Username format validation
            if (!/^[a-z0-9]+$/.test(username)) {
                showLoginFeedback('Username can only contain letters and numbers', 'error');
                return;
            }

            // Check if username already exists
            if (users[username]) {
                showLoginFeedback('This username is already taken. Please choose another.', 'error');
                return;
            }

            // Check if nickname already exists
            const existingUser = Object.keys(users).find(u =>
                users[u].nickname && users[u].nickname.toLowerCase() === nickname.toLowerCase()
            );
            if (existingUser) {
                showLoginFeedback('This display name is already taken. Please choose another.', 'error');
                return;
            }

            // Check if this is the first user - they become admin automatically
            const isFirstUser = Object.keys(users).length === 0;

            // Hash the password
            const passwordHash = await hashPassword(password);

            // Get selected supported teams
            const supportedTeams = getSelectedTeams('registerTeamsPicker');

            // Create new user with hashed password
            users[username] = {
                nickname: nickname,
                passwordHash: passwordHash,
                predictions: {},
                totalTries: null,
                supportedTeams: supportedTeams
            };

            await Storage.saveUser(username, users[username]);

            // Make first user an admin
            if (isFirstUser) {
                adminUsernames.push(username);
                await Storage.saveAdminUsernames(adminUsernames);
                showLoginFeedback('Account created! As the first user, you are now an Admin. Welcome, ' + toTitleCase(nickname) + '!', 'info');
            } else {
                showLoginFeedback('Competitor account created! Welcome, ' + toTitleCase(nickname) + '!', 'info');
            }

            currentUsername = username;
            setCookie('rugbyPredictorUser', username);

            setTimeout(() => {
                showApp();
            }, 1000);
        }

        // Show login feedback
        function showLoginFeedback(message, type) {
            const feedbackEl = document.getElementById('loginFeedback');
            feedbackEl.textContent = message;
            feedbackEl.classList.remove('hidden', 'success', 'error', 'info');
            feedbackEl.classList.add(type);
        }

        // Handle Enter key on login inputs
        function handleLoginKeyPress(event, formType) {
            if (event.key === 'Enter') {
                if (formType === 'existing') {
                    loginExisting();
                } else if (formType === 'new') {
                    registerNewUser();
                }
            }
        }

        // Logout
        function logout() {
            currentUsername = null;
            isGuest = false;
            deleteCookie('rugbyPredictorUser');
            document.getElementById('loginView').classList.remove('hidden');
            document.getElementById('appView').classList.add('hidden');

            // Reset logout button text
            const logoutBtn = document.getElementById('logoutBtn');
            logoutBtn.textContent = 'Logout';

            // Clear all login form fields
            document.getElementById('existingUsername').value = '';
            document.getElementById('existingPassword').value = '';
            document.getElementById('newUsername').value = '';
            document.getElementById('nickname').value = '';
            document.getElementById('newPassword').value = '';

            // Reset to existing user form
            showLoginForm('existing');
        }

        // Show app
        function showApp() {
            isGuest = false;
            document.getElementById('loginView').classList.add('hidden');
            document.getElementById('appView').classList.remove('hidden');

            const user = users[currentUsername];
            let displayName = toTitleCase(user.nickname || currentUsername);

            // Add admin badge if user is admin
            if (isCurrentUserAdmin()) {
                displayName += '<span class="admin-badge">Admin</span>';
                // Show admin tabs
                document.querySelectorAll('.admin-only').forEach(el => el.classList.remove('hidden'));
            } else {
                // Hide admin tabs
                document.querySelectorAll('.admin-only').forEach(el => el.classList.add('hidden'));
            }

            document.getElementById('currentUser').innerHTML = displayName;

            // Show all tabs for logged-in users
            document.querySelector('.tabs:not(.admin-tabs)').classList.remove('hidden');
            document.getElementById('logoutBtn').classList.remove('hidden');

            // Load user's saved theme
            loadUserTheme();

            // Update lock toggle UI
            updateLockToggleUI();

            // Initialize round selector dropdown
            initRoundSelector();

            renderMatches(); // Render the prediction inputs first
            loadPredictions(); // Then populate with saved predictions
            showSummary(); // Load summary by default (includes leaderboard)
        }

        // Show app as guest (view only mode)
        function showAppAsGuest() {
            document.getElementById('loginView').classList.add('hidden');
            document.getElementById('appView').classList.remove('hidden');

            document.getElementById('currentUser').innerHTML = 'Guest <span class="guest-badge">View Only</span>';

            // Hide tabs - guests can only see summary
            document.querySelector('.tabs:not(.admin-tabs)').classList.add('hidden');
            document.querySelectorAll('.admin-only').forEach(el => el.classList.add('hidden'));

            // Change logout button to "Sign In"
            const logoutBtn = document.getElementById('logoutBtn');
            logoutBtn.textContent = 'Sign In';
            logoutBtn.classList.remove('hidden');

            // Initialize round selector dropdown
            initRoundSelector();

            // Hide all tabs except summary
            document.getElementById('predictionsTab').classList.add('hidden');
            document.getElementById('summaryTab').classList.remove('hidden');
            document.getElementById('competitorsTab').classList.add('hidden');
            document.getElementById('resultsTab').classList.add('hidden');
            document.getElementById('recoveryTab').classList.add('hidden');

            // Show summary
            showSummary();
        }

        // Render matches
        function renderMatches() {
            const container = document.getElementById('matchesContainer');
            let currentRound = 0;
            let html = '';
            
            // Calculate outstanding predictions
            const userData = users[currentUsername];
            const completedPredictions = userData && userData.predictions ? Object.keys(userData.predictions).length : 0;
            const totalMatches = matches.length;
            const outstandingCount = totalMatches - completedPredictions;
            const hasTries = userData && userData.totalTries !== null && userData.totalTries !== undefined;
            
            // Show lock status banner at top
            if (appSettings.predictionsLocked) {
                html += '<div class="lock-banner"> Predictions are LOCKED. You cannot make changes.</div>';
            } else {
                html += '<div class="unlock-banner"> Predictions are OPEN. Your changes are saved automatically.</div>';
            }
            
            // Show outstanding predictions banner if there are any
            if (!appSettings.predictionsLocked && (outstandingCount > 0 || !hasTries)) {
                let outstandingText = '';
                if (outstandingCount > 0 && !hasTries) {
                    outstandingText = `<span class="outstanding-banner-count">${outstandingCount}</span> match prediction${outstandingCount !== 1 ? 's' : ''} and <span class="outstanding-banner-count">total tries</span> still to enter`;
                } else if (outstandingCount > 0) {
                    outstandingText = `<span class="outstanding-banner-count">${outstandingCount}</span> match prediction${outstandingCount !== 1 ? 's' : ''} still to enter`;
                } else {
                    outstandingText = `<span class="outstanding-banner-count">Total tries</span> prediction still to enter`;
                }
                html += `<div id="outstandingBanner" class="outstanding-banner">
                    <span class="outstanding-banner-icon"></span>
                    <span class="outstanding-banner-text">${outstandingText}</span>
                </div>`;
            } else if (!appSettings.predictionsLocked) {
                // Add hidden banner that can be shown later if predictions are removed
                html += `<div id="outstandingBanner" class="outstanding-banner" style="display: none;">
                    <span class="outstanding-banner-icon"></span>
                    <span class="outstanding-banner-text"></span>
                </div>`;
            }

            matches.forEach(match => {
                // Add round header if it's a new round
                if (match.round !== currentRound) {
                    currentRound = match.round;
                    html += `<h2 style="font-family: 'Bebas Neue', cursive; font-size: 1.8rem; color: var(--bright-gold); margin: 1.5rem 0 0.75rem 0; letter-spacing: 0.1em;">Round ${currentRound}</h2>`;
                }

                const disabledAttr = appSettings.predictionsLocked ? 'disabled' : '';
                const disabledStyle = appSettings.predictionsLocked ? 'opacity: 0.6; cursor: not-allowed;' : '';
                const onBlurHandler = appSettings.predictionsLocked ? '' : 'onblur="autoSavePredictions()"';

                const isJoker = users[currentUsername] && users[currentUsername].jokerMatchId === match.id;
                const jokerCardClass = isJoker ? ' joker-selected' : '';
                const jokerSection = match.jokerEligible ? `
                    <div class="joker-selection">
                        <label class="joker-label">
                            <input type="radio" name="jokerMatch" class="joker-checkbox" value="${match.id}"
                                ${isJoker ? 'checked' : ''} ${disabledAttr}
                                onchange="selectJoker(${match.id})" style="${disabledStyle}">
                            <span class="joker-icon"></span>
                            <span class="joker-text">Joker (2x points)</span>
                        </label>
                    </div>
                ` : '';

                html += `
                    <div class="match-card${jokerCardClass}" id="match-card-${match.id}">
                        <div class="match-header">${match.date} - ${match.time} <span class="match-saved-indicator" id="saved-${match.id}"></span></div>
                        <div class="match-teams">
                            <div class="team">
                                <div class="team-flag">${getFlag(match.team1)}</div>
                                <div class="team-name">${match.team1}</div>
                                <input type="number" class="score-input" id="team1-${match.id}" min="0" placeholder="0" ${disabledAttr} ${onBlurHandler} style="${disabledStyle}">
                            </div>
                            <div class="vs">VS</div>
                            <div class="team">
                                <div class="team-flag">${getFlag(match.team2)}</div>
                                <div class="team-name">${match.team2}</div>
                                <input type="number" class="score-input" id="team2-${match.id}" min="0" placeholder="0" ${disabledAttr} ${onBlurHandler} style="${disabledStyle}">
                            </div>
                        </div>
                        ${jokerSection}
                    </div>
                `;
            });

            container.innerHTML = html;
            
            // Also disable/enable tries input
            const triesInput = document.getElementById('totalTries');
            
            if (triesInput) {
                triesInput.disabled = appSettings.predictionsLocked;
                triesInput.style.opacity = appSettings.predictionsLocked ? '0.6' : '1';
                triesInput.style.cursor = appSettings.predictionsLocked ? 'not-allowed' : '';
                // Add onblur for auto-save
                if (!appSettings.predictionsLocked) {
                    triesInput.onblur = autoSavePredictions;
                } else {
                    triesInput.onblur = null;
                }
            }
            
            // Update saved indicators for matches that already have predictions
            updateSavedIndicators();
        }

        // Update the saved tick indicators for all matches
        function updateSavedIndicators() {
            const userData = users[currentUsername];
            if (!userData || !userData.predictions) return;
            
            matches.forEach(match => {
                const indicator = document.getElementById(`saved-${match.id}`);
                if (indicator) {
                    if (userData.predictions[match.id]) {
                        indicator.textContent = '';
                        indicator.classList.add('visible');
                    } else {
                        indicator.textContent = '';
                        indicator.classList.remove('visible');
                    }
                }
            });
        }

        // Auto-save predictions on blur
        async function autoSavePredictions() {
            if (appSettings.predictionsLocked) return;
            
            const predictions = {};
            
            matches.forEach(match => {
                const team1Input = document.getElementById(`team1-${match.id}`);
                const team2Input = document.getElementById(`team2-${match.id}`);
                const team1Score = team1Input ? team1Input.value : '';
                const team2Score = team2Input ? team2Input.value : '';
                
                // Only save if BOTH scores have been entered
                if (team1Score !== '' && team2Score !== '') {
                    predictions[match.id] = {
                        team1: parseInt(team1Score),
                        team2: parseInt(team2Score)
                    };
                }
            });

            const totalTriesInput = document.getElementById('totalTries');
            const totalTries = totalTriesInput ? totalTriesInput.value : '';
            const newTries = totalTries ? parseInt(totalTries) : null;

            users[currentUsername].predictions = predictions;
            users[currentUsername].totalTries = newTries;
            await Storage.savePredictions(currentUsername, predictions, newTries);

            // Update the tick indicators
            updateSavedIndicators();
            
            // Update the outstanding banner in real time
            updateOutstandingBanner();
        }
        
        // Select joker match
        async function selectJoker(matchId) {
            if (appSettings.predictionsLocked) return;
            users[currentUsername].jokerMatchId = matchId;
            await Storage.saveUser(currentUsername, users[currentUsername]);
            // Re-render to update card highlight and re-populate inputs
            renderMatches();
            loadPredictions();
        }

        // Update the outstanding predictions banner
        function updateOutstandingBanner() {
            const banner = document.getElementById('outstandingBanner');
            if (!banner) return;
            
            const userData = users[currentUsername];
            const completedPredictions = userData && userData.predictions ? Object.keys(userData.predictions).length : 0;
            const totalMatches = matches.length;
            const outstandingCount = totalMatches - completedPredictions;
            const hasTries = userData && userData.totalTries !== null && userData.totalTries !== undefined;
            
            if (appSettings.predictionsLocked || (outstandingCount === 0 && hasTries)) {
                banner.style.display = 'none';
                return;
            }
            
            banner.style.display = 'flex';
            
            let outstandingText = '';
            if (outstandingCount > 0 && !hasTries) {
                outstandingText = `<span class="outstanding-banner-count">${outstandingCount}</span> match prediction${outstandingCount !== 1 ? 's' : ''} and <span class="outstanding-banner-count">total tries</span> still to enter`;
            } else if (outstandingCount > 0) {
                outstandingText = `<span class="outstanding-banner-count">${outstandingCount}</span> match prediction${outstandingCount !== 1 ? 's' : ''} still to enter`;
            } else {
                outstandingText = `<span class="outstanding-banner-count">Total tries</span> prediction still to enter`;
            }
            
            banner.querySelector('.outstanding-banner-text').innerHTML = outstandingText;
        }

        // Save predictions
        // Load predictions
        function loadPredictions() {
            const userData = users[currentUsername];
            if (userData.predictions) {
                Object.keys(userData.predictions).forEach(matchId => {
                    const pred = userData.predictions[matchId];
                    document.getElementById(`team1-${matchId}`).value = pred.team1;
                    document.getElementById(`team2-${matchId}`).value = pred.team2;
                });
            }
            if (userData.totalTries) {
                document.getElementById('totalTries').value = userData.totalTries;
            }
        }

        // Calculate points based on scoring rules
        function calculatePoints(username) {
            const user = users[username];
            let totalPoints = 0;

            matches.forEach(match => {
                // Skip matches that haven't been played yet
                if (match.actualScore1 === null || match.actualScore2 === null) {
                    return;
                }

                const prediction = user.predictions[match.id];
                if (!prediction) {
                    return;
                }

                const actualResult = getResult(match.actualScore1, match.actualScore2);
                const predictedResult = getResult(prediction.team1, prediction.team2);

                let matchPoints = 0;

                // 3 points for correct result (win/draw prediction)
                if (actualResult === predictedResult) {
                    matchPoints += 3;

                    // Check for perfect score OR within 5 points
                    const team1Diff = Math.abs(prediction.team1 - match.actualScore1);
                    const team2Diff = Math.abs(prediction.team2 - match.actualScore2);

                    if (team1Diff === 0 && team2Diff === 0) {
                        // Perfect score - 3 bonus points
                        matchPoints += 3;
                    } else {
                        // 1 extra point for each team score within 5 points (max 2)
                        if (team1Diff <= 5) matchPoints += 1;
                        if (team2Diff <= 5) matchPoints += 1;
                    }

                    // Bonus 2 points for correctly predicting a draw
                    if (actualResult === 'draw') {
                        matchPoints += 2;
                    }
                }

                // Double points if this is the user's joker match
                if (user.jokerMatchId === match.id) {
                    matchPoints *= 2;
                }

                totalPoints += matchPoints;
            });

            return totalPoints;
        }

        // Helper function to determine result (win/draw)
        function getResult(score1, score2) {
            if (score1 > score2) return 'team1';
            if (score2 > score1) return 'team2';
            return 'draw';
        }

        // Update leaderboard
        function updateLeaderboard() {
            // Update tries stats and Trev's Tips
            updateTriesStats();
        }

        // Update the tries stats display above leaderboard
        function updateTriesStats() {
            const container = document.getElementById('triesStatsContainer');
            if (!container) return;
            
            const totalActualTries = getTotalActualTries();
            const completedMatches = matches.filter(m => m.actualTries1 !== null && m.actualTries2 !== null).length;
            const totalMatches = matches.length;
            const remainingMatches = totalMatches - completedMatches;
            
            let estimatedTotal = '-';
            let avgPerMatch = '-';
            
            if (completedMatches > 0) {
                avgPerMatch = (totalActualTries / completedMatches).toFixed(1);
                estimatedTotal = Math.round((totalActualTries / completedMatches) * totalMatches);
            }
            
            container.innerHTML = `
                <div class="tries-stats-title">Tournament Tries</div>
                <div class="tries-stats-grid">
                    <div class="tries-stat">
                        <div class="tries-stat-value">${totalActualTries}</div>
                        <div class="tries-stat-label">Tries So Far</div>
                    </div>
                    <div class="tries-stat">
                        <div class="tries-stat-value">${completedMatches}/${totalMatches}</div>
                        <div class="tries-stat-label">Matches Completed</div>
                    </div>
                    <div class="tries-stat">
                        <div class="tries-stat-value">${avgPerMatch}</div>
                        <div class="tries-stat-label">Avg Per Match</div>
                    </div>
                    <div class="tries-stat">
                        <div class="tries-stat-value">${estimatedTotal}</div>
                        <div class="tries-stat-label">Estimated Total</div>
                    </div>
                </div>
            `;
            
            // Update Trev's Tips
            updateTrevsTips();
        }

        // Generate Trev's Tips - fun commentary on the competition
        function updateTrevsTips() {
            const container = document.getElementById('trevsTipsContainer');
            if (!container) return;
            
            const allUsers = Object.keys(users);
            if (allUsers.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            // Get leaderboard data
            const leaderboardData = allUsers.map(username => ({
                nickname: toTitleCase(users[username].nickname || username),
                points: calculatePoints(username),
                username: username
            })).sort((a, b) => b.points - a.points);
            
            // Get completed matches with results
            const completedMatches = matches.filter(m => m.actualScore1 !== null && m.actualScore2 !== null);
            const recentMatch = completedMatches.length > 0 ? completedMatches[completedMatches.length - 1] : null;
            
            // Generate tips based on current state
            let tip = '';
            
            const gloucesterRefs = [
                "showing the kind of form Gloucester had in the 2002-03 Zurich Premiership",
                "more dominant than Gloucester's pack on a muddy Kingsholm afternoon",
                "channeling serious Cherry and White energy",
                "playing it tighter than a Gloucester maul five metres out",
                "with the precision of a prime James Simpson-Daniel sidestep",
                "looking sharper than Mike Teague on a charge against the All Blacks",
                "more relentless than a Kingsholm crowd in full voice on a Friday night",
                "as solid as the Shed End faithful in December",
                "with the guile of a young Jeremy Guscott cutting through the defence",
                "fiercer than the Bath-Gloucester derby in the 80s",
                "tougher than playing at the Rec in February without gloves",
                "more committed than Phil Vickery scrummaging on a wet Wednesday",
                "steadier than Don Caskie slotting penalties in the wind",
                "showing more heart than Gloucester's 2003 Powergen Cup final win",
                "hungrier than a young Olly Morgan chasing a high ball",
                "more unpredictable than a Friday night under the lights at Kingsholm",
                "with the power of the Cherry and Whites in their Heineken Cup days",
                "as fearless as Marcel Garvey running at a full defence",
                "with the footwork of Terry Fanolua dancing through tackles",
                "hitting harder than Junior Paramore on a rampaging burst",
                "showing the consistency of Andy Gomarsall's box kicking",
                "as reliable as Henry Paul pulling the strings at fly-half",
                "more clinical than Ludovic Mercier slotting kicks from the touchline",
                "with the vision of Ryan Lamb spotting gaps in the defence",
                "as explosive as Lesley Vainikolo in full flight down the wing",
                "tougher than the Kingsholm pitch after a week of West Country rain",
                "showing the never-say-die attitude of the 2006-07 EDF Energy Cup winners"
            ];
            
            const rugbyRefs = [
                "Could this be their Jonny Wilkinson moment?",
                "Unlike England in that glorious 2003 final, there's still time on the clock!",
                "Showing the composure of Jonny Wilkinson lining up THAT drop goal in Sydney.",
                "Remember when Wilko slotted that drop goal? That's the energy we need here.",
                "More clinical than England's 2003 World Cup campaign (and that's saying something!).",
                "Reminds me of the 1980 Grand Slam - Bill Beaumont would be proud!",
                "Playing with the flair of the great French sides of the 80s.",
                "Serge Blanco would approve of this counter-attacking style!",
                "More dramatic than the 1990 Grand Slam decider at Murrayfield.",
                "Channeling the spirit of the 1987 World Cup - when it all began!",
                "Tighter than Wales vs England at the old Arms Park in '87.",
                "As unpredictable as a Campese goose-step on the try line.",
                "More nerve-wracking than the 2019 World Cup semi-finals!",
                "Showing the resilience of South Africa in that 1995 final - Mandela would approve.",
                "Like watching the All Blacks in their 2011 World Cup campaign - clinical when it matters.",
                "Has the drama of that 2015 World Cup when Japan shocked the Springboks!",
                "More twists and turns than the 2007 World Cup when anyone could win it.",
                "Reminds me of Ireland's Grand Slam in 2009 - the fairytale might just happen!",
                "As tense as England vs Australia in the 1991 World Cup final.",
                "Showing the grit of Wales in their 2019 Grand Slam campaign.",
                "Like the French in 1999 - capable of producing magic when least expected!",
                "More exciting than Lomu's demolition of England in '95.",
                "With the tactical nous of Clive Woodward's 2003 masterclass.",
                "As thrilling as Brian O'Driscoll carving through defences in his prime.",
                "Showing the leadership of Martin Johnson lifting the Webb Ellis Cup.",
                "More physical than the Lions vs All Blacks in 2017 - proper Test match stuff!",
                "With the kicking game of Dan Carter orchestrating from fly-half.",
                "As dramatic as that 2023 World Cup final - edge of your seat stuff!",
                "Reminds me of Scotland's famous Calcutta Cup wins at Twickenham.",
                "Playing with the passion of a packed Principality Stadium on match day.",
                "More intense than the 1997 Lions series in South Africa - legendary!",
                "Showing the finishing of Shane Williams at his devastating best."
            ];
            
            const randomGloucester = gloucesterRefs[Math.floor(Math.random() * gloucesterRefs.length)];
            const randomRugby = rugbyRefs[Math.floor(Math.random() * rugbyRefs.length)];
            const randomGloucester2 = gloucesterRefs[Math.floor(Math.random() * gloucesterRefs.length)];
            const nextMatch = matches.find(m => m.actualScore1 === null || m.actualScore2 === null);
            const historicRefs = {
                'England|France': 'England 2517 France in 2003',
                'England|Ireland': 'England 2428 Ireland in 2006',
                'England|Scotland': 'England 433 Scotland in 2001',
                'England|Wales': 'Wales 119 England in 2005',
                'France|Ireland': 'France 2527 Ireland in 2000',
                'France|Italy': 'Italy 339 France in 2007',
                'France|Scotland': 'France 4619 Scotland in 2007',
                'France|Wales': 'Wales 2912 France in 2008',
                'Ireland|Italy': 'Italy 2451 Ireland in 2007',
                'Ireland|Scotland': 'Ireland 3413 Scotland in 2008',
                'Ireland|Wales': 'Wales 1517 Ireland in 2009',
                'Italy|Scotland': 'Scotland 1737 Italy in 2007',
                'Italy|Wales': 'Wales 478 Italy in 2008',
                'England|Italy': 'Italy 1923 England in 2008',
                'Scotland|Wales': 'Wales 3015 Scotland in 2008'
            };
            const matchKey = nextMatch ? [nextMatch.team1, nextMatch.team2].sort().join('|') : '';
            const nextFixtureText = nextMatch
                ? `Next up we have ${nextMatch.team1} vs ${nextMatch.team2} on ${nextMatch.date} at ${nextMatch.time}.`
                : '';
            const historicRef = matchKey && historicRefs[matchKey]
                ? [
                    `I remember the classic ${historicRefs[matchKey]}.`,
                    `Will it match the classic ${historicRefs[matchKey]}?`,
                    `Could it beat the classic ${historicRefs[matchKey]}?`,
                    `Hard to top the classic ${historicRefs[matchKey]}.`,
                    `That ${historicRefs[matchKey]} clash set the bar  can this one rise to it?`
                ][Math.floor(Math.random() * 5)]
                : '';
            const nextFixtureWithHistory = `${nextFixtureText} ${historicRef}`.trim();
            
            if (completedMatches.length === 0) {
                tip = `No matches played yet, but the tension is building like the 2003 World Cup final in extra time! Get your predictions in sharpish - this isn't a Gloucester training session where you can take your time. The tournament kicks off soon and every point counts. Make sure you've got all your scores in before kick-off - no late changes allowed once the whistle blows! Remember, predicting a draw gets you bonus points, and if you nail the exact score, you'll be celebrating like Gloucester winning the Premiership. ${nextFixtureWithHistory}`;
            } else if (leaderboardData.length === 1) {
                tip = `${leaderboardData[0].nickname} is currently the only competitor - ${randomGloucester}! Bit lonely at the top though, like being the only person who remembers Gloucester's Powergen Cup wins. Get some mates involved and make this a proper competition! The more the merrier, as they say down at Kingsholm on match day. ${nextFixtureWithHistory}`;
            } else {
                const leader = leaderboardData[0];
                const second = leaderboardData[1];
                const gap = leader.points - second.points;
                const remainingMatches = matches.length - completedMatches.length;
                
                // Build match analysis with more detail
                let matchAnalysis = '';
                if (completedMatches.length > 0) {
                    const recentMatch = completedMatches[completedMatches.length - 1];
                    const scoreDiff = Math.abs(recentMatch.actualScore1 - recentMatch.actualScore2);
                    const totalPoints = recentMatch.actualScore1 + recentMatch.actualScore2;
                    const winner = recentMatch.actualScore1 > recentMatch.actualScore2 ? recentMatch.team1 : 
                                   recentMatch.actualScore2 > recentMatch.actualScore1 ? recentMatch.team2 : null;
                    const loser = recentMatch.actualScore1 < recentMatch.actualScore2 ? recentMatch.team1 : 
                                  recentMatch.actualScore2 < recentMatch.actualScore1 ? recentMatch.team2 : null;
                    
                    if (winner) {
                        if (scoreDiff > 30) {
                            matchAnalysis = `Blimey! ${winner} absolutely annihilated ${loser} ${recentMatch.actualScore1}-${recentMatch.actualScore2} - that's the kind of hammering you don't see often in international rugby! ${loser} will want to forget that one quickly. Reminds me of when the All Blacks used to put 50 on teams in the early 2000s. `;
                        } else if (scoreDiff > 20) {
                            matchAnalysis = `${winner} put ${loser} to the sword with a dominant ${recentMatch.actualScore1}-${recentMatch.actualScore2} victory - a proper thrashing that would make the old Kingsholm faithful proud! ${loser} had no answer to that kind of pressure. Anyone who predicted that margin deserves a pint! `;
                        } else if (scoreDiff > 10) {
                            matchAnalysis = `${winner} claimed a convincing ${recentMatch.actualScore1}-${recentMatch.actualScore2} win over ${loser}. A solid performance that showed real class and composure when it mattered. ${loser} competed but couldn't live with ${winner}'s intensity in the key moments. `;
                        } else if (scoreDiff <= 3) {
                            matchAnalysis = `What a nail-biter! ${winner} scraped past ${loser} ${recentMatch.actualScore1}-${recentMatch.actualScore2} - tighter than a Gloucester scrum on their own five-metre line! Could have gone either way right until the final whistle. That's the kind of match that makes this tournament special. If you got that result right, take a bow! `;
                        } else {
                            matchAnalysis = `${winner} edged out ${loser} ${recentMatch.actualScore1}-${recentMatch.actualScore2} in a hard-fought contest. Neither side gave an inch, proper Test match rugby that was. ${loser} will feel they let that one slip, but ${winner} showed composure when it counted. `;
                        }
                        
                        // High scoring game
                        if (totalPoints > 60) {
                            matchAnalysis += `A ${totalPoints}-point thriller - the defences will be getting a talking to after that one! `;
                        } else if (totalPoints < 25) {
                            matchAnalysis += `Low-scoring but brutal - a real arm-wrestle between two tough teams. `;
                        }
                    } else {
                        matchAnalysis = `A ${recentMatch.actualScore1}-${recentMatch.actualScore2} draw between ${recentMatch.team1} and ${recentMatch.team2}! You don't see many of those in international rugby - rarer than a sunny day at Kingsholm in February! If anyone predicted that exact score, they deserve a standing ovation from the Shed. That's seriously impressive prediction work. `;
                    }
                    
                    // Add tries analysis if available
                    if (recentMatch.actualTries1 !== null && recentMatch.actualTries2 !== null) {
                        const totalTries = recentMatch.actualTries1 + recentMatch.actualTries2;
                        if (totalTries >= 10) {
                            matchAnalysis += `${totalTries} tries in one match - that's an absolute try-fest! The kind of rugby we all want to see. `;
                        } else if (totalTries >= 8) {
                            matchAnalysis += `${totalTries} tries in total - proper running rugby that keeps the crowd on their feet! `;
                        } else if (totalTries <= 2) {
                            matchAnalysis += `Only ${totalTries} tries though - a real forwards' battle that one, the kind of game where every scrum matters. `;
                        } else if (totalTries <= 4) {
                            matchAnalysis += `${totalTries} tries tells you it was tight and tense - defences on top throughout. `;
                        }
                    }
                }
                
                // Overall tournament stats with more analysis
                let tournamentStats = '';
                if (completedMatches.length >= 3) {
                    const totalActualTries = getTotalActualTries();
                    const avgTries = (totalActualTries / completedMatches.length).toFixed(1);
                    const totalPointsScored = completedMatches.reduce((sum, m) => sum + m.actualScore1 + m.actualScore2, 0);
                    const avgPointsPerGame = (totalPointsScored / completedMatches.length).toFixed(0);
                    
                    tournamentStats = `Tournament stats: ${totalActualTries} tries across ${completedMatches.length} matches (${avgTries} per game), averaging ${avgPointsPerGame} points per match. `;
                    
                    if (avgTries > 7) {
                        tournamentStats += `This is shaping up to be a high-scoring tournament - good news for the try prediction! `;
                    } else if (avgTries < 5) {
                        tournamentStats += `Defences have been on top - those predicting lower try totals might be onto something. `;
                    }
                }
                
                // Who predicted well in recent match
                let predictionAnalysis = '';
                if (recentMatch) {
                    const correctPredictions = allUsers.filter(username => {
                        const pred = users[username].predictions[recentMatch.id];
                        if (!pred) return false;
                        const actualResult = getResult(recentMatch.actualScore1, recentMatch.actualScore2);
                        const predictedResult = getResult(pred.team1, pred.team2);
                        return actualResult === predictedResult;
                    });
                    
                    if (correctPredictions.length === 0) {
                        predictionAnalysis = `Nobody got that result right - ${recentMatch.team1} vs ${recentMatch.team2} caught everyone out! `;
                    } else if (correctPredictions.length === 1) {
                        const winner = toTitleCase(users[correctPredictions[0]].nickname || correctPredictions[0]);
                        predictionAnalysis = `Only ${winner} called that one correctly - sharp stuff! `;
                    } else if (correctPredictions.length <= 3) {
                        predictionAnalysis = `Only ${correctPredictions.length} competitors got the result right - not an easy one to call! `;
                    }
                }
                
                if (gap === 0) {
                    tip = `It's tighter than the 2003 World Cup final at the top! ${leader.nickname} and ${second.nickname} are level on ${leader.points} points - ${randomGloucester}. ${matchAnalysis}${predictionAnalysis}${tournamentStats}With ${remainingMatches} matches still to play, this one's going down to the wire like England vs Australia in Sydney! Every prediction counts now - one perfect score could swing it all. ${nextFixtureWithHistory}`;
                } else if (gap <= 3) {
                    tip = `${leader.nickname} leads with ${leader.points} points but ${second.nickname} is breathing down their neck like a Gloucester flanker hunting a fly-half! Only ${gap} point${gap > 1 ? 's' : ''} separating them. ${matchAnalysis}${predictionAnalysis}${tournamentStats}With ${remainingMatches} matches left, one good round of predictions could change everything. This is proper squeaky-bum time, as they say! ${nextFixtureWithHistory}`;
                } else if (gap <= 6) {
                    tip = `${leader.nickname} is building a handy lead on ${leader.points} points, but ${second.nickname} on ${second.points} won't give up without a fight - ${randomGloucester}. ${matchAnalysis}${predictionAnalysis}${tournamentStats}Still ${remainingMatches} matches to play, which means plenty of points up for grabs. A couple of perfect scores and this leaderboard could look very different. ${nextFixtureWithHistory}`;
                } else if (gap <= 10) {
                    tip = `${leader.nickname} is pulling clear on ${leader.points} points - ${randomGloucester}! ${second.nickname} trails by ${gap} points and needs to find form quickly. ${matchAnalysis}${predictionAnalysis}${tournamentStats}But don't count anyone out yet - remember Japan beating South Africa at the 2015 World Cup? Anything's possible in this game! ${nextFixtureWithHistory}`;
                } else {
                    tip = `${leader.nickname} is running away with it on ${leader.points} points - ${randomGloucester}! ${second.nickname} trails by ${gap} points and needs a serious comeback worthy of the 1999 French team against the All Blacks. ${matchAnalysis}${predictionAnalysis}${tournamentStats}The gap looks big, but ${remainingMatches} matches means up to ${remainingMatches * 11} points still available. Stranger things have happened - ${randomGloucester2}! ${nextFixtureWithHistory}`;
                }
            }
            
            container.innerHTML = `
                <div class="trevs-tips-header">
                    <span class="trevs-tips-emoji"></span>
                    <span class="trevs-tips-title">Trev's Tips</span>
                </div>
                <div class="trevs-tips-content">${tip}</div>
            `;
        }

        // Show all predictions
        function showAllPredictions() {
            const container = document.getElementById('allPredictionsContainer');
            container.innerHTML = Object.keys(users).map(username => {
                const user = users[username];
                const displayName = toTitleCase(user.nickname || username);
                return `
                    <div class="user-predictions">
                        <h3>${displayName}'s Predictions - Total Points: <span class="points">${calculatePoints(username)}</span></h3>
                        ${matches.map(match => {
                            const pred = user.predictions[match.id];
                            if (!pred) return '';
                            
                            let pointsEarned = 0;
                            let statusColor = '';
                            let statusText = '';

                            // Calculate points for this match if results are in
                            if (match.actualScore1 !== null && match.actualScore2 !== null) {
                                const actualResult = getResult(match.actualScore1, match.actualScore2);
                                const predictedResult = getResult(pred.team1, pred.team2);

                                if (actualResult === predictedResult) {
                                    pointsEarned = 3;
                                    statusColor = '#2ecc71';
                                    statusText = ' Correct Result (+3)';

                                    const team1Diff = Math.abs(pred.team1 - match.actualScore1);
                                    const team2Diff = Math.abs(pred.team2 - match.actualScore2);

                                    if (team1Diff <= 5 || team2Diff <= 5) {
                                        pointsEarned = 4;
                                        statusText = ' Correct + Bonus (+4)';
                                    }
                                } else {
                                    statusColor = '#e74c3c';
                                    statusText = ' Incorrect (0)';
                                }
                            }

                            const isJoker = user.jokerMatchId === match.id;
                            const jokerBadge = isJoker ? ' <span class="joker-indicator"></span>' : '';
                            const scoreClass = isJoker ? 'predicted-score joker-score' : 'predicted-score';

                            return `
                                <div class="prediction-row">
                                    <div><strong>${match.team1} vs ${match.team2}</strong><br><small style="opacity: 0.7;">${match.date}</small></div>
                                    <div class="${scoreClass}">${pred.team1} - ${pred.team2}${jokerBadge}</div>
                                    <div style="color: ${statusColor}; font-weight: 600;">${statusText}</div>
                                </div>
                            `;
                        }).join('')}
                        <div class="prediction-row">
                            <div><strong>Total Tries Prediction</strong></div>
                            <div class="predicted-score">${user.totalTries || 'Not set'}</div>
                            <div></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Current filter state
        let currentFilter = 'all';
        let selectedRound = 1;

        // Initialize the round selector dropdown
        function initRoundSelector() {
            const select = document.getElementById('roundSelect');
            if (!select) return;
            
            // Get unique rounds from matches
            const rounds = [...new Set(matches.map(m => m.round))].sort((a, b) => a - b);
            
            // Determine the default round based on current date/tournament progress
            selectedRound = getDefaultRound();
            
            // Get the first match date for each round
            const roundDates = {};
            rounds.forEach(r => {
                const roundMatches = matches.filter(m => m.round === r);
                if (roundMatches.length > 0) {
                    // Get the first match date in this round
                    roundDates[r] = roundMatches[0].date || 'TBD';
                }
            });
            
            // Populate dropdown with round and date
            select.innerHTML = rounds.map(r => {
                const dateStr = roundDates[r] || 'TBD';
                return `<option value="${r}" ${r === selectedRound ? 'selected' : ''}>Round ${r} (${dateStr})</option>`;
            }).join('');
        }

        // Get the default round to show (similar logic to old "This Weekend")
        // Logic: Show the round that contains the most recent incomplete match,
        // or if all matches are complete, show the most recent completed round.
        // If no matches have been played, show the first round.
        function getDefaultRound() {
            const now = new Date();
            
            // Find rounds with their completion status
            const roundStatus = {};
            matches.forEach(m => {
                if (!roundStatus[m.round]) {
                    roundStatus[m.round] = { total: 0, completed: 0, hasIncomplete: false };
                }
                roundStatus[m.round].total++;
                if (m.actualScore1 !== null && m.actualScore2 !== null) {
                    roundStatus[m.round].completed++;
                } else {
                    roundStatus[m.round].hasIncomplete = true;
                }
            });
            
            const rounds = Object.keys(roundStatus).map(Number).sort((a, b) => a - b);
            
            // Find the first round that has incomplete matches (current/upcoming round)
            for (const round of rounds) {
                if (roundStatus[round].hasIncomplete) {
                    return round;
                }
            }
            
            // All matches complete - return the last round
            return rounds.length > 0 ? rounds[rounds.length - 1] : 1;
        }

        // Handle round select dropdown change
        function onRoundSelectChange() {
            const select = document.getElementById('roundSelect');
            selectedRound = parseInt(select.value);
            
            // Automatically switch to round filter when dropdown is changed
            currentFilter = 'round';
            
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.round-filter-group .filter-btn').classList.add('active');
            
            // Refresh the view
            showSummary();
        }

        // Filter matches based on selected filter
        function filterMatches(filterType) {
            currentFilter = filterType;
            
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Refresh summary
            showSummary();
        }

        // Get filtered matches based on current filter
        function getFilteredMatches() {
            if (currentFilter === 'completed') {
                return matches.filter(m => m.actualScore1 !== null && m.actualScore2 !== null);
            } else if (currentFilter === 'round') {
                return matches.filter(m => m.round === selectedRound);
            }
            
            return matches; // 'all'
        }

        // Show comprehensive summary with matches as columns
        function showSummary() {
            const container = document.getElementById('summaryContainer');
            const allUsers = Object.keys(users);
            
            if (allUsers.length === 0) {
                container.innerHTML = '<p style="text-align: center; font-size: 1.2rem; opacity: 0.7;">No competitors have registered yet.</p>';
                updateLeaderboard();
                return;
            }

            const filteredMatches = getFilteredMatches();
            
            if (filteredMatches.length === 0) {
                container.innerHTML = '<p style="text-align: center; font-size: 1.2rem; opacity: 0.7;">No matches match the current filter.</p>';
                updateLeaderboard();
                return;
            }

            // Calculate total actual tries so far
            const totalActualTries = getTotalActualTries();
            const completedMatches = matches.filter(m => m.actualTries1 !== null && m.actualTries2 !== null).length;
            const totalMatches = matches.length;

            let html = '<div class="summary-container">';
            html += '<table class="summary-table">';
            
            // Header row: Rank | Competitor | Score | Match 1 | Match 2 | ... | Predicted Tries
            html += '<thead><tr>';
            html += '<th class="rank-col">#</th>';
            html += '<th class="competitor-col">Competitor</th>';
            html += '<th class="pts-col">Score</th>';
            filteredMatches.forEach(match => {
                const hasResult = match.actualScore1 !== null && match.actualScore2 !== null;
                const hasTries = match.actualTries1 !== null && match.actualTries2 !== null;
                const totalMatchTries = hasTries ? match.actualTries1 + match.actualTries2 : null;
                const jokerBadge = match.jokerEligible ? '<div class="joker-eligible-badge"> Joker Eligible</div>' : '<div class="joker-eligible-badge" style="visibility: hidden;"> Joker Eligible</div>';
                html += `<th class="match-header-cell ${match.jokerEligible ? 'joker-eligible-header' : ''}">
                    <div class="match-header-cell-inner">
                        <div class="match-header-top">
                            ${jokerBadge}
                            <div class="match-teams">${getFlag(match.team1)} ${match.team1}<br>vs<br>${getFlag(match.team2)} ${match.team2}</div>
                            <div class="match-date">${match.date} - ${match.time}</div>
                        </div>
                        <div class="match-header-bottom">
                            ${hasResult ? `<div class="match-result">${match.actualScore1} - ${match.actualScore2}</div>` : '<div class="no-result">-</div>'}
                            ${hasTries ? `<div class="match-tries">(${totalMatchTries} tries)</div>` : ''}
                        </div>
                    </div>
                </th>`;
            });
            // Only show Tries column if not filtering by weekend
            if (currentFilter !== 'round') {
                html += '<th class="tries-col">Predicted Tries</th>';
            }
            html += '</tr></thead>';
            
            html += '<tbody>';
            
            // Sort competitors by total points
            const sortedUsers = Object.keys(users)
                .map(username => ({
                    username: username,
                    nickname: toTitleCase(users[username].nickname || username),
                    totalPoints: calculatePoints(username)
                }))
                .sort((a, b) => b.totalPoints - a.totalPoints);
            
            // Row for each competitor
            sortedUsers.forEach((user, index) => {
                // Calculate rank (handle ties)
                let rank = index + 1;
                if (index > 0 && sortedUsers[index - 1].totalPoints === user.totalPoints) {
                    // Same points as previous user, find the first user with this score
                    for (let i = index - 1; i >= 0; i--) {
                        if (sortedUsers[i].totalPoints === user.totalPoints) {
                            rank = i + 1;
                        } else {
                            break;
                        }
                    }
                }
                
                // Check if this is the current logged in user
                const isCurrentUser = user.username === currentUsername;
                const rowClass = isCurrentUser ? 'current-user-row' : '';
                
                html += `<tr class="${rowClass}">`;
                html += `<td class="rank-col">${rank}</td>`;
                html += `<td class="competitor-name">${getUserFlags(user.username)}${user.nickname}</td>`;
                html += `<td class="pts-col">${user.totalPoints}</td>`;

                // Column for each match
                filteredMatches.forEach(match => {
                    const pred = users[user.username].predictions[match.id];
                    const hasResult = match.actualScore1 !== null && match.actualScore2 !== null;
                    
                    if (!pred) {
                        html += '<td>-</td>';
                        return;
                    }
                    
                    let pointsEarned = 0;
                    let pointsClass = 'points-0';
                    let tooltipContent = '';
                    const isJoker = users[user.username].jokerMatchId === match.id;

                    if (hasResult) {
                        const actualResult = getResult(match.actualScore1, match.actualScore2);
                        const predictedResult = getResult(pred.team1, pred.team2);

                        const team1Diff = Math.abs(pred.team1 - match.actualScore1);
                        const team2Diff = Math.abs(pred.team2 - match.actualScore2);

                        // Build tooltip content
                        tooltipContent += `<span class="tooltip-line">Predicted: ${pred.team1} - ${pred.team2}</span>`;
                        tooltipContent += `<span class="tooltip-line">Actual: ${match.actualScore1} - ${match.actualScore2}</span>`;

                        if (actualResult === predictedResult) {
                            pointsEarned = 3;
                            pointsClass = 'points-3';
                            tooltipContent += `<span class="tooltip-line correct"> Correct result: +3 pts</span>`;

                            // Check for perfect score OR within 5 points
                            if (team1Diff === 0 && team2Diff === 0) {
                                pointsEarned += 3;
                                pointsClass = 'points-perfect';
                                tooltipContent += `<span class="tooltip-line bonus"> Perfect score: +3 pts</span>`;
                            } else {
                                // 1 extra point for each team score within 5 points (max 2)
                                if (team1Diff <= 5) {
                                    pointsEarned += 1;
                                    tooltipContent += `<span class="tooltip-line bonus"> ${match.team1} score within 5: +1 pt</span>`;
                                }
                                if (team2Diff <= 5) {
                                    pointsEarned += 1;
                                    tooltipContent += `<span class="tooltip-line bonus"> ${match.team2} score within 5: +1 pt</span>`;
                                }
                                if (team1Diff <= 5 || team2Diff <= 5) {
                                    pointsClass = 'points-4';
                                }
                            }

                            // Bonus 2 points for correctly predicting a draw
                            if (actualResult === 'draw') {
                                pointsEarned += 2;
                                tooltipContent += `<span class="tooltip-line bonus"> Draw bonus: +2 pts</span>`;
                            }
                        } else {
                            tooltipContent += `<span class="tooltip-line incorrect"> Wrong result: 0 pts</span>`;
                        }

                        // Apply joker doubling
                        if (isJoker) {
                            tooltipContent += `<span class="tooltip-line joker-bonus"> Joker: ${pointsEarned}  2 = ${pointsEarned * 2} pts</span>`;
                            pointsEarned *= 2;
                        }

                        tooltipContent += `<span class="tooltip-line" style="margin-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 0.5rem;">Total: ${pointsEarned} pts</span>`;
                    }

                    const jokerIndicator = isJoker ? '<span class="joker-indicator"></span>' : '';
                    const jokerScoreClass = isJoker ? 'joker-score' : '';
                    const jokerCellClass = isJoker ? 'prediction-cell joker-cell' : 'prediction-cell';
                    const score1 = pred.team1;
                    const score2 = pred.team2;
                    let score1Class = 'pred-score';
                    let score2Class = 'pred-score';
                    if (score1 > score2) {
                        score1Class += ' pred-score-win';
                        score2Class += ' pred-score-lose';
                    } else if (score2 > score1) {
                        score1Class += ' pred-score-lose';
                        score2Class += ' pred-score-win';
                    } else {
                        score1Class += ' pred-score-tie';
                        score2Class += ' pred-score-tie';
                    }

                    if (isJoker) {
                        tooltipContent += `<span class="tooltip-line joker-bonus"> Joker selection: points are doubled</span>`;
                    }

                    if (hasResult) {
                        html += `<td class="${jokerCellClass}">
                            <div class="tooltip-container">
                                <div class="${jokerScoreClass}"><span class="${score1Class}">${score1}</span> - <span class="${score2Class}">${score2}</span> ${jokerIndicator}</div>
                                <span class="points-earned ${pointsClass}">${pointsEarned} pts</span>
                                <div class="tooltip">${tooltipContent}</div>
                            </div>
                        </td>`;
                    } else {
                        if (isJoker) {
                            html += `<td class="${jokerCellClass}">
                                <div class="tooltip-container">
                                    <div class="${jokerScoreClass}"><span class="${score1Class}">${score1}</span> - <span class="${score2Class}">${score2}</span> ${jokerIndicator}</div>
                                    <span class="points-earned points-placeholder">&nbsp;</span>
                                    <div class="tooltip">${tooltipContent}</div>
                                </div>
                            </td>`;
                        } else {
                            html += `<td class="${jokerCellClass}">
                                <div class="${jokerScoreClass}"><span class="${score1Class}">${score1}</span> - <span class="${score2Class}">${score2}</span> ${jokerIndicator}</div>
                                <span class="points-earned points-placeholder">&nbsp;</span>
                            </td>`;
                        }
                    }
                });
                
                // Predicted tries column with calculated projection (only if not weekend filter)
                if (currentFilter !== 'round') {
                    const userTries = users[user.username].totalTries;
                    let predictedTriesDisplay = '-';
                    let projectedTries = null;
                    
                    if (userTries !== null && userTries !== undefined) {
                        // Calculate average tries per game from user's predictions and project to 15 games
                        const userPredictions = users[user.username].predictions;
                        const numPredictions = Object.keys(userPredictions).length;
                        
                        if (numPredictions > 0 && completedMatches > 0) {
                            // Calculate average actual tries per completed match
                            const avgTriesPerMatch = totalActualTries / completedMatches;
                            // Project to full tournament
                            projectedTries = Math.round(avgTriesPerMatch * totalMatches);
                            predictedTriesDisplay = `<div class="tooltip-container">${userTries}<div class="tooltip"><span class="tooltip-line">User prediction: ${userTries}</span><span class="tooltip-line">Avg tries/match: ${avgTriesPerMatch.toFixed(1)}</span><span class="tooltip-line">Projected total: ${projectedTries}</span></div></div>`;
                        } else {
                            predictedTriesDisplay = userTries;
                        }
                    }
                    
                    html += `<td class="tries-col">${predictedTriesDisplay}</td>`;
                }
                
                html += '</tr>';
            });
            
            html += '</tbody>';
            html += '</table>';
            html += '<div class="scroll-hint hidden" id="scrollHint"><span>Scroll right to see full table</span><span class="scroll-hint-arrow"></span></div>';
            html += '</div>';

            container.innerHTML = html;
            updateLeaderboard();
            checkTableOverflow();
        }

        function checkTableOverflow() {
            const container = document.querySelector('.summary-container');
            const scrollHint = document.getElementById('scrollHint');
            if (!container || !scrollHint) return;

            // Show hint if table is wider than container
            if (container.scrollWidth > container.clientWidth) {
                scrollHint.classList.remove('hidden');
            } else {
                scrollHint.classList.add('hidden');
            }

            // Hide hint when user scrolls to the end
            container.addEventListener('scroll', function() {
                const isScrolledToEnd = container.scrollLeft + container.clientWidth >= container.scrollWidth - 10;
                if (isScrolledToEnd) {
                    scrollHint.classList.add('hidden');
                }
            });

            // Enable touch tooltips for mobile
            initTouchTooltips();
        }

        function exportToPDF() {
            const allMatches = matches;

            const sortedUsers = Object.keys(users)
                .map(username => ({
                    username,
                    nickname: toTitleCase(users[username].nickname || username),
                    totalPoints: calculatePoints(username)
                }))
                .sort((a, b) => b.totalPoints - a.totalPoints);

            function getMatchPoints(username, match) {
                const pred = users[username].predictions[match.id];
                const hasResult = match.actualScore1 !== null && match.actualScore2 !== null;
                if (!pred || !hasResult) return null;
                let pts = 0;
                const actualResult = getResult(match.actualScore1, match.actualScore2);
                const predictedResult = getResult(pred.team1, pred.team2);
                const t1Diff = Math.abs(pred.team1 - match.actualScore1);
                const t2Diff = Math.abs(pred.team2 - match.actualScore2);
                if (actualResult === predictedResult) {
                    pts = 3;
                    if (t1Diff === 0 && t2Diff === 0) { pts += 3; }
                    else { if (t1Diff <= 5) pts += 1; if (t2Diff <= 5) pts += 1; }
                    if (actualResult === 'draw') pts += 2;
                }
                if (users[username].jokerMatchId === match.id) pts *= 2;
                return pts;
            }

            function hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return [r, g, b];
            }

            const countryAbbr = { 'England': 'ENG', 'France': 'FRA', 'Ireland': 'IRE', 'Italy': 'ITA', 'Scotland': 'SCO', 'Wales': 'WAL' };
            function getPdfUserFlags(username) {
                const teams = users[username] && users[username].supportedTeams ? users[username].supportedTeams : [];
                if (teams.length === 0) return '';
                return teams.map(t => countryAbbr[t] || t).join('/') + ' ';
            }

            // Printer-friendly palette
            const C = {
                black: '#111111',
                gray: '#666666',
                lightGray: '#DADADA',
                border: '#BEBEBE',
                white: '#FFFFFF',
                winFg: '#0B6B2C',
                loseFg: '#C0392B',
                drawFg: '#D4820A',
                pointsFg: '#5A4A00',
                pendingHomeWin: '#2471A3',
                pendingAwayWin: '#7D3C98',
                pendingDraw: '#D4820A',
                exactBg: '#C6EFCE',
            };

            // --- Initialise PDF ---
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });

            // Title
            const now = new Date();
            doc.setFontSize(18);
            doc.setFont('helvetica', 'bold');
            doc.text('Six Nations Guesser \u2014 Match Summary', 14, 15);

            const dateStr = now.toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(102, 102, 102);
            doc.text('Exported ' + dateStr, 14, 22);
            doc.setTextColor(0, 0, 0);

            // --- Calculate actual + estimated tries ---
            const totalActualTries = getTotalActualTries();
            const completedTriesMatches = allMatches.filter(m => m.actualTries1 !== null && m.actualTries2 !== null).length;
            const totalMatchCount = allMatches.length;
            let estimatedTotalTries = null;
            if (completedTriesMatches > 0) {
                estimatedTotalTries = Math.round((totalActualTries / completedTriesMatches) * totalMatchCount);
            }

            // --- Build header row ---
            const headerRow = [
                { content: '#', styles: { halign: 'center' } },
                { content: 'Name', styles: { halign: 'left' } },
                { content: 'Score', styles: { halign: 'center' } },
                ...allMatches.map(m => ({
                    content: m.team1 + ' vs ' + m.team2 + '\n' + m.date + ' ' + m.time,
                    styles: { halign: 'center' }
                })),
                { content: 'Predicted\nTries', styles: { halign: 'center' } }
            ];

            // --- Build actual results row ---
            const actualRow = [
                { content: '', styles: { textColor: hexToRgb(C.gray) } },
                { content: 'Actual Result', styles: { textColor: hexToRgb(C.gray), halign: 'left' } },
                { content: '', styles: { textColor: hexToRgb(C.gray) } },
                ...allMatches.map(m => {
                    const hasResult = m.actualScore1 !== null && m.actualScore2 !== null;
                    const hasTries = m.actualTries1 !== null && m.actualTries2 !== null;
                    if (hasResult) {
                        let txt = m.actualScore1 + ' - ' + m.actualScore2;
                        if (hasTries) txt += '  (' + (m.actualTries1 + m.actualTries2) + ' tries)';
                        // Color by result: green for home win score, draw orange
                        let resultColor;
                        if (m.actualScore1 > m.actualScore2) resultColor = hexToRgb(C.winFg);
                        else if (m.actualScore1 < m.actualScore2) resultColor = hexToRgb(C.loseFg);
                        else resultColor = hexToRgb(C.drawFg);
                        return { content: txt, styles: { textColor: resultColor, fontStyle: 'bold', fontSize: 8 } };
                    }
                    return { content: 'TBD', styles: { textColor: hexToRgb(C.gray) } };
                }),
                { content: completedTriesMatches > 0 ? totalActualTries + ' (' + estimatedTotalTries + ')' : '', styles: { textColor: hexToRgb(C.gray), fontStyle: 'bold', fontSize: 7 } }
            ];

            // --- Build data rows ---
            const dataRows = sortedUsers.map((user, index) => {
                let rank = index + 1;
                if (index > 0 && sortedUsers[index - 1].totalPoints === user.totalPoints) {
                    for (let i = index - 1; i >= 0; i--) {
                        if (sortedUsers[i].totalPoints === user.totalPoints) rank = i + 1; else break;
                    }
                }

                const row = [
                    { content: String(rank), styles: { fontStyle: 'bold', halign: 'center' } },
                    { content: user.nickname, styles: { fontStyle: 'bold', halign: 'left' } },
                    { content: String(user.totalPoints), styles: { fontStyle: 'bold', textColor: hexToRgb(C.pointsFg), fontSize: 9 } },
                ];

                allMatches.forEach(match => {
                    const pred = users[user.username].predictions[match.id];
                    const hasResult = match.actualScore1 !== null && match.actualScore2 !== null;
                    const isJoker = users[user.username].jokerMatchId === match.id;

                    if (!pred) {
                        row.push({ content: '\u2014', styles: { textColor: hexToRgb(C.gray) } });
                        return;
                    }

                    const pts = getMatchPoints(user.username, match);
                    const predLabel = pred.team1 + ' - ' + pred.team2;
                    const jokerTag = isJoker ? '  [J]' : '';

                    if (!hasResult) {
                        // Pending match  color by predicted result
                        const predictedResult = getResult(pred.team1, pred.team2);
                        let textColor;
                        if (predictedResult === 'team1') textColor = hexToRgb(C.pendingHomeWin);
                        else if (predictedResult === 'team2') textColor = hexToRgb(C.pendingAwayWin);
                        else textColor = hexToRgb(C.pendingDraw);

                        row.push({
                            content: predLabel + jokerTag,
                            styles: { textColor: textColor, fontStyle: isJoker ? 'bold' : 'normal' }
                        });
                    } else {
                        // Completed match  color by whether prediction was correct
                        const actualResult = getResult(match.actualScore1, match.actualScore2);
                        const predictedResult = getResult(pred.team1, pred.team2);
                        const isExact = pred.team1 === match.actualScore1 && pred.team2 === match.actualScore2;
                        let fillColor = null;
                        let fontStyle = 'normal';
                        let textColor;

                        if (actualResult === predictedResult) {
                            // Correct result prediction  green
                            textColor = hexToRgb(C.winFg);
                            if (isExact) {
                                fillColor = hexToRgb(C.exactBg);
                                fontStyle = 'bold';
                            } else if (pts >= 6 || isJoker) {
                                fontStyle = 'bold';
                            }
                        } else {
                            // Wrong result prediction  red
                            textColor = hexToRgb(C.loseFg);
                        }

                        // Draw predictions get orange tint
                        if (actualResult === 'draw' && predictedResult === 'draw') {
                            textColor = hexToRgb(C.drawFg);
                            fontStyle = 'bold';
                        }

                        if (isJoker) fontStyle = 'bold';

                        const cellStyles = { textColor: textColor, fontStyle: fontStyle };
                        if (fillColor) cellStyles.fillColor = fillColor;

                        row.push({
                            content: predLabel + jokerTag + '\n' + pts + ' pts',
                            styles: cellStyles
                        });
                    }
                });

                // Predicted Tries
                const userTries = users[user.username].totalTries;
                row.push({
                    content: userTries != null ? String(userTries) : '\u2014',
                    styles: { textColor: hexToRgb(C.black) }
                });

                return row;
            });

            // --- Render table ---
            const pageWidth = doc.internal.pageSize.getWidth();
            const marginLR = 6;
            const tableWidth = pageWidth - marginLR * 2;
            const fixedWidth = 8 + 28 + 13 + 16; // rank + name + score + tries
            const matchColWidth = Math.max(14, (tableWidth - fixedWidth) / allMatches.length);
            const lastMatchCol = 3 + allMatches.length;
            const colStyles = {
                0: { cellWidth: 8 },
                1: { cellWidth: 28 },
                2: { cellWidth: 13 },
            };
            for (let i = 3; i < lastMatchCol; i++) {
                colStyles[i] = { cellWidth: matchColWidth };
            }
            colStyles[lastMatchCol] = { cellWidth: 16 };

            doc.autoTable({
                head: [headerRow],
                body: [actualRow, ...dataRows],
                startY: 28,
                theme: 'grid',
                tableWidth: tableWidth,
                styles: {
                    fontSize: 8,
                    cellPadding: 1.5,
                    lineColor: hexToRgb(C.border),
                    lineWidth: 0.2,
                    halign: 'center',
                    valign: 'middle',
                    overflow: 'linebreak',
                    font: 'helvetica',
                },
                headStyles: {
                    fillColor: hexToRgb(C.white),
                    textColor: hexToRgb(C.black),
                    fontStyle: 'bold',
                    fontSize: 7,
                    halign: 'center',
                    lineColor: hexToRgb(C.border),
                    lineWidth: 0.3,
                },
                columnStyles: colStyles,
                didParseCell: function(data) {
                    // Thicker right border on Score column to separate fixed columns from matches
                    if (data.column.index === 2) {
                        data.cell.styles.lineWidth = { bottom: 0.2, top: 0.2, left: 0.2, right: 0.5 };
                    }
                    // Thicker bottom border on actual results row (first body row)
                    if (data.section === 'body' && data.row.index === 0) {
                        const lw = data.cell.styles.lineWidth;
                        if (typeof lw === 'object') {
                            lw.bottom = 0.5;
                        } else {
                            data.cell.styles.lineWidth = { bottom: 0.5, top: 0.2, left: 0.2, right: data.column.index === 2 ? 0.5 : 0.2 };
                        }
                    }
                },
                margin: { top: 10, left: marginLR, right: marginLR },
            });

            // --- Download ---
            doc.save('SixNations_Summary_' + now.toISOString().slice(0, 10) + '.pdf');
        }

        function initTouchTooltips() {
            // Add click/touch handlers for tooltip containers
            document.querySelectorAll('.summary-container .tooltip-container').forEach(container => {
                container.addEventListener('click', function(e) {
                    e.stopPropagation();

                    // Close any other open tooltips
                    document.querySelectorAll('.tooltip-container.tooltip-active').forEach(el => {
                        if (el !== container) {
                            el.classList.remove('tooltip-active');
                        }
                    });

                    // Toggle this tooltip
                    container.classList.toggle('tooltip-active');
                });
            });

            // Close tooltips when clicking elsewhere
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.tooltip-container')) {
                    document.querySelectorAll('.tooltip-container.tooltip-active').forEach(el => {
                        el.classList.remove('tooltip-active');
                    });
                }
            });
        }

        // Database Recovery Functions
        function generateSchemaSQL() {
            return `-- Drop existing tables (in correct order due to foreign keys)
DROP TABLE IF EXISTS predictions;
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS matches;
DROP TABLE IF EXISTS admin_usernames;
DROP TABLE IF EXISTS settings;

-- Create users table
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    nickname VARCHAR(255),
    password_hash VARCHAR(255),
    total_tries INTEGER,
    joker_match_id INTEGER,
    supported_teams VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create matches table
CREATE TABLE matches (
    id INTEGER PRIMARY KEY,
    round INTEGER NOT NULL,
    date VARCHAR(50),
    time VARCHAR(10),
    team1 VARCHAR(100) NOT NULL,
    team2 VARCHAR(100) NOT NULL,
    actual_score1 INTEGER,
    actual_score2 INTEGER,
    actual_tries1 INTEGER,
    actual_tries2 INTEGER,
    joker_eligible BOOLEAN DEFAULT FALSE
);

-- Create predictions table
CREATE TABLE predictions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    match_id INTEGER NOT NULL,
    team1_score INTEGER,
    team2_score INTEGER,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, match_id)
);

-- Create admin_usernames table
CREATE TABLE admin_usernames (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL
);

-- Create settings table
CREATE TABLE settings (
    id SERIAL PRIMARY KEY,
    key VARCHAR(255) UNIQUE NOT NULL,
    value TEXT
);

-- Enable Row Level Security (optional - adjust as needed)
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE predictions ENABLE ROW LEVEL SECURITY;
ALTER TABLE matches ENABLE ROW LEVEL SECURITY;
ALTER TABLE admin_usernames ENABLE ROW LEVEL SECURITY;
ALTER TABLE settings ENABLE ROW LEVEL SECURITY;

-- Create policies for public access (adjust based on your security needs)
CREATE POLICY "Allow all access to users" ON users FOR ALL USING (true);
CREATE POLICY "Allow all access to predictions" ON predictions FOR ALL USING (true);
CREATE POLICY "Allow all access to matches" ON matches FOR ALL USING (true);
CREATE POLICY "Allow all access to admin_usernames" ON admin_usernames FOR ALL USING (true);
CREATE POLICY "Allow all access to settings" ON settings FOR ALL USING (true);`;
        }

        function generateDataSQL() {
            let sql = '';

            // Helper to escape single quotes in SQL strings
            const esc = (str) => str ? str.replace(/'/g, "''") : '';

            // Generate matches INSERT statements
            if (matches.length > 0) {
                sql += '\n-- Insert matches data\n';
                matches.forEach(m => {
                    sql += `INSERT INTO matches (id, round, date, time, team1, team2, actual_score1, actual_score2, actual_tries1, actual_tries2, joker_eligible) VALUES (${m.id}, ${m.round}, '${esc(m.date)}', '${esc(m.time)}', '${esc(m.team1)}', '${esc(m.team2)}', ${m.actualScore1 === null ? 'NULL' : m.actualScore1}, ${m.actualScore2 === null ? 'NULL' : m.actualScore2}, ${m.actualTries1 === null ? 'NULL' : m.actualTries1}, ${m.actualTries2 === null ? 'NULL' : m.actualTries2}, ${m.jokerEligible ? 'TRUE' : 'FALSE'});\n`;
                });
            }

            // Generate admin_usernames INSERT statements
            if (adminUsernames.length > 0) {
                sql += '\n-- Insert admin usernames\n';
                adminUsernames.forEach(u => {
                    sql += `INSERT INTO admin_usernames (username) VALUES ('${esc(u)}');\n`;
                });
            }

            // Generate settings INSERT statements
            sql += '\n-- Insert settings\n';
            sql += `INSERT INTO settings (key, value) VALUES ('predictionsLocked', '${appSettings.predictionsLocked}');\n`;

            // Generate users INSERT statements
            const userList = Object.keys(users);
            if (userList.length > 0) {
                sql += '\n-- Insert users\n';
                userList.forEach((username, index) => {
                    const u = users[username];
                    const oderId = index + 1;
                    const supportedTeamsVal = u.supportedTeams && u.supportedTeams.length > 0 ? `'${esc(u.supportedTeams.join(','))}'` : 'NULL';
                    sql += `INSERT INTO users (id, username, nickname, password_hash, total_tries, joker_match_id, supported_teams) VALUES (${oderId}, '${esc(username)}', '${esc(u.nickname)}', '${esc(u.passwordHash)}', ${u.totalTries === null || u.totalTries === undefined ? 'NULL' : u.totalTries}, ${u.jokerMatchId === null || u.jokerMatchId === undefined ? 'NULL' : u.jokerMatchId}, ${supportedTeamsVal});\n`;
                });

                // Generate predictions INSERT statements
                sql += '\n-- Insert predictions\n';
                userList.forEach((username, userIndex) => {
                    const userId = userIndex + 1;
                    const predictions = users[username].predictions || {};
                    Object.keys(predictions).forEach(matchId => {
                        const pred = predictions[matchId];
                        sql += `INSERT INTO predictions (user_id, match_id, team1_score, team2_score) VALUES (${userId}, ${matchId}, ${pred.team1}, ${pred.team2});\n`;
                    });
                });

                // Reset the sequence for users table
                sql += '\n-- Reset sequences\n';
                sql += `SELECT setval('users_id_seq', (SELECT MAX(id) FROM users));\n`;
                sql += `SELECT setval('predictions_id_seq', (SELECT MAX(id) FROM predictions));\n`;
                sql += `SELECT setval('admin_usernames_id_seq', (SELECT MAX(id) FROM admin_usernames));\n`;
                sql += `SELECT setval('settings_id_seq', (SELECT MAX(id) FROM settings));\n`;
            }

            return sql;
        }

        function generateFullSQL(includeData = true) {
            if (includeData) {
                return generateSchemaSQL() + '\n' + generateDataSQL();
            } else {
                return generateSchemaSQL();
            }
        }

        function updateRecoverySQL() {
            const includeData = document.getElementById('includeDataCheckbox').checked;
            const sql = generateFullSQL(includeData);
            document.getElementById('sqlPreview').textContent = sql;

            // Update description and list based on checkbox
            const description = document.getElementById('recoveryDescription');
            const list = document.getElementById('recoveryList');

            if (includeData) {
                description.textContent = 'This SQL will recreate all tables and restore:';
                list.innerHTML = `
                    <li>All matches and fixtures</li>
                    <li>All user accounts (usernames, password hashes)</li>
                    <li>All predictions</li>
                    <li>Admin usernames list</li>
                    <li>App settings</li>
                `;
            } else {
                description.textContent = 'This SQL will recreate empty tables only:';
                list.innerHTML = `
                    <li>Empty matches table</li>
                    <li>Empty users table</li>
                    <li>Empty predictions table</li>
                    <li>Empty admin_usernames table</li>
                    <li>Empty settings table</li>
                `;
            }
        }

        function initRecoveryTab() {
            // Display the SQL based on checkbox state
            updateRecoverySQL();
        }

        function copySqlToClipboard() {
            const includeData = document.getElementById('includeDataCheckbox').checked;
            const sql = generateFullSQL(includeData);
            navigator.clipboard.writeText(sql).then(() => {
                alert('SQL copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = sql;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('SQL copied to clipboard!');
            });
        }

        // Tab switching
        function showTab(tabName) {
            // Hide all tabs
            document.getElementById('predictionsTab').classList.add('hidden');
            document.getElementById('summaryTab').classList.add('hidden');
            document.getElementById('competitorsTab').classList.add('hidden');
            document.getElementById('resultsTab').classList.add('hidden');
            document.getElementById('recoveryTab').classList.add('hidden');

            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

            // Show selected tab
            if (tabName === 'predictions') {
                document.getElementById('predictionsTab').classList.remove('hidden');
                event.target.classList.add('active');
                renderMatches(); // Re-render to check lock status
                loadPredictions(); // Pre-populate with saved predictions
            } else if (tabName === 'summary') {
                document.getElementById('summaryTab').classList.remove('hidden');
                event.target.classList.add('active');
                refreshSummaryData();
            } else if (tabName === 'competitors') {
                if (!isCurrentUserAdmin()) return;
                document.getElementById('competitorsTab').classList.remove('hidden');
                event.target.classList.add('active');
                renderCompetitorManagement();
            } else if (tabName === 'results') {
                if (!isCurrentUserAdmin()) return;
                document.getElementById('resultsTab').classList.remove('hidden');
                event.target.classList.add('active');
                updateLockToggleUI();
                renderAdminMatches();
            } else if (tabName === 'recovery') {
                if (!isCurrentUserAdmin()) return;
                document.getElementById('recoveryTab').classList.remove('hidden');
                event.target.classList.add('active');
                initRecoveryTab();
            }
        }

        async function refreshSummaryData() {
            try {
                // Show a subtle loading state on the summary container
                const container = document.getElementById('matchSummary');
                if (container) {
                    container.style.opacity = '0.6';
                }

                // Fetch fresh data from Supabase
                const [loadedUsers, loadedMatches] = await Promise.all([
                    Storage.getUsers(),
                    Storage.getMatches()
                ]);

                // Update local data
                users = loadedUsers;
                if (loadedMatches && loadedMatches.length > 0) {
                    matches.length = 0;
                    loadedMatches.forEach(m => matches.push(m));
                }

                // Restore opacity and show summary
                if (container) {
                    container.style.opacity = '1';
                }
                showSummary();

            } catch (error) {
                console.error('Error refreshing summary data:', error);
                // Still show summary with existing data if refresh fails
                showSummary();
            }
        }

        // Initialize on load - load data from Supabase first
        initializeData().then(() => {
            init();

            // Check for saved user cookie and auto-login
            const savedUsername = getCookie('rugbyPredictorUser');
            if (savedUsername && users[savedUsername]) {
                currentUsername = savedUsername;
                showApp();
            }
        });
    </script>
</body>
</html>
